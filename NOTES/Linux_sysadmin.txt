## FILE SYSTEM HEIRARCHY
> '/'		- base level
> /boot 	- boot loader lives here
> /bin 		- system binaries
> /sbin 	- super user binaries (these binaries require effective id of root user to run)
> /lib 		- system libraries (i.e. libraries that system binaries will  use) live here
> /dev 		- devices live here
> /etc 		- all configuration files

> /home		- users and their files live here
> /proc 	- virtual/in-memory filesystem (all processes reside here)
> /root 	- root user's home
> /tmp 		- temporary storage
> /var 		- temporal files
> /media 	- removable/mounted storage resides here
> /mnt 		- temporary filesystem (can be used to store temporarily mounted devices)
> /usr 		- distribution's and user's own directory (place for custom software/tools to be installed). 
	> /usr/bin 			- distribution(or sometimes user) installed binaries live here
	> /usr/lib 			- libraries for distribution installed binaries live here
	> /usr/share		- contains arch. independent shared text files
	...
	> /usr/local 		- user's locally installed softwares are supposed to be installed (firefox)
	> /usr/local/bin  	- user's locally installed software binaries are present here
	> /usr/local/lib	- libraries for user's locally installed binaries.


## Interesting directories

# These files deciede where the system log goes:
> /etc/rsyslog.d					; configuration directory for system logger program (rsyslog daemon)
  /etc/rsyslog.d/50-default.conf	; configure where 'facility.priority' messages/logs go
> /etc/default/rsyslog 				; add flags to the syslog server at its bootup.
> /etc/systemd/journald.conf		; configure journal daemon for SysV init systems (what and what not 
									; should journalctl program log)
> /etc/logrotate.d/					; this directory stores files by all programs who wants their logs
									; managed.
  /etc/logrotate.conf 				; configuration file for logrotate program.

> /etc/skel 			; scripts (.bash_logout, .bashrc, .profile) stored here are copied to home
						; directory whenever a new user account is created.
						; .bashrc - initialization script for user account
						; .bash_logout - destructor script for login shell of a particular user
						; .profile - initialization script executed by login shells

> /sys/class			; sys filesystem stores kernel parameters. Read it to know for eg: your CPU
						; temperature, battery power, change backlit led brightness (manipulate 
						; devices) etc.

> /etc/hosts				; local DNS file that our system consults before reaching out to DNS server.  
> /etc/inittab				; set up default runlevels everytime the system boots up on a 
							; distribution running sysVinit as init system.

> /etc/systemd/system/		; expore what options do we have as Boot Targets
> /usr/lib/systemd/system/

> /etc/default/grub 		; configuration file for GRUB2
> /boot/grub/menu.lst 		; configuration file for legacy GRUB 

> /etc/ld.so.conf 			; usually stores the path/points to /etc/ld.so.conf.d
> /etc/ld.so.conf.d/		; has *.conf files storing paths consulted by ld.so while resolving 
							; dependencies

> /etc/apt/sources.list 	; list of all the internet repositories the system can get updates from.
> /etc/apt/sources.list.d/	; has *.list files containing links to internet repositories
> /etc/yum.conf 			; configure yum
> /etc/yum.repos.d/ 		; has files containing links to internet repos.

> /etc/fstab				; to permanently mount devices at particular points in filesystem at 
							; every bootup

> /etc/profile 				; file permissions (umask defined)
> /etc/login.defs 			; 
> /etc/bashrc				; 

# System wide profiles
> /etc/profile				; scripts stored here are executed as soon as a user logs in through any 
> /etc/profile.d			; login shell (like ssh where user needs to enter username and password 
							; for access)
> /etc/bash.bashrc 			; system-wide executed when user launches an interactive shell. 

> /etc/passwd				; all users created on the system are stored here	
> /etc/shadow 				; stores one-way hashed passwords for users on machine. If we can read 
							; this file we may be able to crack user password using Hascat
> /etc/gshadow				; shadow file for groups

> /etc/crontab				; systemwide crontab
> /etc/cron.d 				; stores crontab files
> /etc/cron.daily 			; stores scripts to be executed daily   (executable files/scripts)
> /etc/cron.monthly  		; stores scripts to be executed monthly (executable files/scripts)
> /var/spool/anacron		; keeps track through timestamp, whether script was executed or not.
> /var/spool/cron/crontabs/<username> 	; file generated by command 'crontab -e' to schedule tasks 
										; on behalf of user who issues the command.
> /etc/cron.allow 						; users specified in it are whitelisted to run 'crontab -e'
> /etc/cron.deny						; users specified in it are blacklisted to run 'crontab -e'
> /etc/at.allow 						; users specified in it are whitelisted to run 'at'
> /etc/at.deny 							; users specified in it are blacklisted to run 'at'

> /etc/aliases 				; System-wide mail forwarding -> configure who gets root users emails

# NETWORKING
> /etc/services 			; stores all the standard services and port numbers they run on.
> /etc/hostname				; edit it to change the hostname of our machine
> /etc/hosts 				; Can put DNS entries (kind of a local DNS queried even before a request
							; is made out to any DNS server on internet to resolve any domain name)
> /etc/network/interfaces 	; a one-in-all file to configure network interfaces.
> /etc/resolv.conf			; automatically generated file storing DNS address.
> /etc/nsswitch.conf		; (n)ame(s)erver (s)witch file to configure name (domain name) resolution
							; order (i.e. does it consult local or remote DNS first)

# SECURITY 
> /etc/security/limits.conf 		; used to set limits to system resources system-wide
> ~/.ssh/known_hosts 				; stores the public key of all the machines the user connected 
									; to in past.
> /etc/ssh/*.pub		; our machine's public key (generated with various algorithms ecdsa, rsa etc.)



2. Hardware Integration
=> /dev stores all the devices attached to the system. Includes sda (pointer to harddrive) where 
   'sd*' stands for 'SCSI devices' (sda1, sda2, sda3 ... representing various partitions of 
   harddrive), sdb (perhaps pendrive), tty's etc.
=> /dev stores pointers to all the hardware devices attached to the system whose driver module
   (in the form of LKM) is inserted into the Linux Kernel.

	0.	uname -a 		; print system information
	1.	lsmod			; list of active LKMs
	2.	insmod			; insert LKMs  
	3.	rmmod			; remove LKMs
	4.	modprobe		; insert/remove LKMs

3. Hotplug  device - that can be plugged in without requiring a shutdown.
   Coldplug device - that require system to be shuted down in order to get plugged in. 

  	5.	lspci			; lists 'PCI' devices plugged to the system.
  	6.	lsusb			; lists 'usb devices' plugged to the system.
  	7.	usb-devices		; detailed info. about each usb device o/p by 'lsusb'.
  	8.	dmesg			; print(default) or control kernel ring buffer (kernel operations log)
 

4. Virtual FileSystem (memory-based FS)
=> 'procfs' (to store process info) and 'sysfs' (to store system info like device info).

	9.	udev  			; populates the /dev dir using sysfs (knows via driver code).
	10.	dbus			; a signalling system that uses the info in /dev dir and relays that info
						  to the OS in the form of signals.


5. Bootup Process
=> BIOS -> MBR/UEFI -> GRUB -> initrd -> kernel -> init --> all other processes

	>>> BIOS - performs POST and activate all hardware devices (ethernet, wifi adapter, memory etc..)
	>>> MBR/UEFI - at CHS(0,0,1) is of 512 bytes (446 bootloader + 64 partition table + 2 digital signature)
	>>> GRUB - Chainloading process to load a 'minimal kernel' - initrd to memory and transfer execution.
	>>> initrd - kind of a minimal kernel to mount hard drive and figure out which kernel modules
				 to load given a specific hardware.
	>>> kernel loads (gets from disk to memory)
	>>> init/systemd - kernel runs init/systemd process (PID 1)
	>>> all other processes are child to 'init/systemd' process.


6. Boot Time Kernel Commands
=> At GRUB menu, press 'a' to modify kernel arguments before bootup. (to pass a kernel command for the
   single bootup session).

	>>> Type ' single' and press enter (for single user mode where you can change your root password*)
	
	A program can run in various modes or 'runlevels' (analogous to Optimus Prime in transformers)
	Three ways or init systems(programs) on Linux, i.e. the process of initialization of kernel (launching 
	daemons, processes etc)

		* SysVinit => CentOS 7 (dying)
			> runlevels
			> numbered order of startup scripts (eg: network card is initialized/started up before 
			  apache webserver)
			> lots of symblinks (startup scripts are run via lots of symblinks like /etc/rc1.d,
			  /etc/rc2.d etc...)
			> not that efficient

		* Upstart
			> faster startup
			> start order not just numerical
			> backward compatible

		* Systemd => Ubuntu
			> 'systemctl' command is 'systemd configuration program' to stop/start services or daemons.
			> not backward compatible.
			> uses binary code not just scripts.


7. Managing Runlevels running SysVinit as init system (/etc/inittab)
=> Runlevels are different modes in which the system is in or how will it interact with network/users etc.
   Use '/etc/inittab' file (present only on a distro running on sysVinit init system) to set up default
   runlevel everytime a system boots up.

	11.	runlevel 		; displays the previous and current runlevel
   	12.	telinit	3		; tell init program to swith to runlevel 3			
   	13. init 6			; improper way of switching to runlevel 6

   	Runlevels (from 0-6) may vary as per distribution -
   		
   		** Debian/Ubuntu
   		=> Below is the mapping between runlevels and the boot targets 

   			RUNLEVEL: BOOT TARGETS
   			> 0 	: poweroff  (halt)
   			> 1 	: rescue    (Single User Mode)
   			> 2-4	: multiuser (Nothing)
   			> 5 	: graphical (Full, Multi-user, GUI if installed)
   			> 6		: reboot

   		** CentOS/Suse
   			> 0 	: Halt
   			> 1		: Single User Mode
   			> 2		: Multi-user, not networking
   			> 3		: Multi-user, with networking
   			> 4		: Nothing
   			> 5 	: Multi-user GUI
   			> 6		: Reboot


8. Managing Boot Targets running Systemd as init system
=> How to switch between boot targets (shown just above) and how to set the default.
   Analogous to how sysVinit has Runlevels, systemd type init system has Boot targets !
   A single tool to manage Systemd target targets --> 'systemctl'.

    14.	systemctl isolate multi-user.target 		; switch to boot target 
   	15.	systemctl get-default						; get default boot target
   	16.	systemctl set-default graphical.target  	; set default boot target

   	Note: you would not want to set-default boot target to reboot (dangerous)

   	## POWERING OFF the right way

   	17.	halt 		; sometimes it might not poweroff the motherboard (keep it in halted state)
   	18. poweroff	; sends ACPI poweroff signal (which poweroffs the motherboard)
   	19. reboot 		; reboots but with -f option, it sends a kill signal to every process

   	18. echo "message" | wall 		; wall program will send the message to every terinal

   	19. shutdown -r now 			; reboot the system 'right now'
   		shutdown -P 14:16			; poweroff the system when the clock hits 14:16
   		shutdown -h +2 "msg"		; take the system to halted state after '2 minutes' with
   									; "msg" broadcasted to all terminals on the system.


10. Partitions and Mount points
=> 	MBR and GPT are 2 partitioning schemes.
	MBR allowed the BIOS to find bootloader and partition table info in 1st sector of HDD,
	i.e. 512 bytes (446 + 64 + 2) which is a block size. MBR also restricted the admin to
	have 4 partitions in total among which 1 partition is extended partition (which can
	further have many partitions). 


11.	RAID V/S LVM
=>	Both are used to manage drives. Tradeoffs are between - 
	* Performance
	* Reliability
	
	# RAID (Redundant Array of Independent Disks)
	It is a solution to prevent Disk Failures or SPOFs (Single Point Of Failure).
		
		* Stripped RAID (RAID 0)
		> Divides and distributes data into all the drives 
		
		* Mirrored RAID (RAID 1)
		> Copies or backs up the data (by compromizing half of the storage). Therefore data
		  is written in multiple places and thus mirrored.
		
		* Parity RAID (RAID 5)
		> Divides and distributes data into all drives except one. The left drive
	      (parity drive) acts as the damaged drive. Parity drive is only effective when only
	      one drive is lost. If more than one drive has failure, all data is lost.

	# LVM (Logical Volume Manger) (a disk management approach)
	Combines many physical drives into a single logical drive (as an illusion to the OS) after
	which the admin can perform various partitions considering a single logical unit of storage.
	Downside is ofcourse if one of the physical drive fails, everything's down. Can increase the
	FS space (reflected at logical/OS level) at any time just by attaching a new drive 
	(unlike RAID).


12.	Bootloaders (GRUB legacy and GRUB2)
=>	GRand Unified Bootloader work in multiple stages -

	* Stage - 1 : MBR (the 446 byte of bootloader code points the code flow to /boot dir location
				  by referring the partition table info, i.e. of 64 bytes)
	* Stage - 2 : /boot contains the next stage bootloader and kernel. 

	# GRUB legacy
		> Configuration file: /boot/grub/menu.lst
		> grub-install	(default installation location is /dev/sda)
		> grub-update	(doesn't really need it after we configure menu.lst)

	# GRUB2
		> Configuration file: /boot/grub/grub.cfg or
							  /etc/grub2/grub.cfg
						----> /etc/default/grub
						----> /etc/grub.d/...
		> Installation      : grub2-install or grub-install
						----> grub2-mkconfig -o /etc/grub2/grub.cfg

	## Debian/Ubuntu
		- grub2 since 2009
		- backwards compatible scripts (like grub-install)
		- boot folder : /boot/grub/grub.cfg (grub-mkconfig -o )

	## Linux Enterprise 6 (CentOS 6.5)
		- grub legacy
		- no grub2 tools
		- grub-install

	## Linux Enterprise 7+
		- grub2
		- no backward compatibility scripts
		- boot folder : /boot/grub2/
 

	$$ CONFIGURING GRUB in various distros
	=> To configure legacy grub, its simple, just configure /boot/grub/menu.lst.
	   To configure moder grub2, we have to edit /etc/default/grub and just generate grub.cfg
	   file using 'grub-mkconfig' tool in /boot/grub/ directory.

	 	# CONFIGURING legacy GRUB  (in CentOS 6)
	 	$ vim /boot/grub/menu.lst
	 	$ update-grub

		# CONFIGURING GRUB2 (in Ubuntu)
		$ vim /etc/default/grub
		$ ls -l /boot/grub/grub.cfg 			
				--> see the timestamp, it is not updated with changes yet
		$ grub-mkconfig -o /boot/grub/grub.cfg 
				--> creates grub.cfg as per changes done in /etc/default/grub
		$ ls -l /boot/grub/grub.cfg
				--> see the updated timestamp which ensures our settings are reflected as .cfg file

		# CONFIGURING GRUB2 (in CentOS 7+)
		$ vim /etc/default/grub2
		$ grub2-mkconfig -o /boot/grub2/grub.cfg 
				--> creates grub.cfg as per changes done in /etc/default/grub


13.	Dynamic Linker (ld.so) and Shared Libraries
=>	/etc/*.conf file is a directive to other *.conf files. These *.conf files store the path which
	determines all the directories where the dynamic linker (ld.so) will check for the
	dependencies (shared libs) while linking an invoked program.

	/etc/
		|-- ld.so.conf 			
		|-- ld.so.cache				# created by 'ldconfig' program
		|-- ld.so.conf.d/
			|
			|-- libc.conf
			|-- linux.conf
			|-- vmware.conf

	20.	sudo ldconfig	; after adding a *.conf file, update the cache via ldconfig
	21.	ldd ./bin		; lists the dependencies used by 'bin' program.

	## Adding a custom shared library
	=> This can be done via 2 ways -
		
		* Syste Wide effect
			- Creating a '/etc/ld.so.conf.d/<mylib>.conf' file and writing PATH_TO_CUSTOM_SO inside it.
			- run $ sudo ldconfig 		# to update /etc/ld.so.cache

		* Particular Session effect
			- export LD_LIBRARY_PATH="/PATH_TO_CUSTOM_SO/:$LD_LIBRARY_PATH" 
			- now along with /etc/ld.so.cache, ld.so will look at 'PATH_TO_CUSTOM_SO' env var too.


14.	Using APT
=>	Packages can be thought of as 'setup.exe' for windows. Debian has *.deb and Red Hat has *.rpm extension to 
	packages.
	Can use aptitude tool in place of apt-get and apt-cache.
		
		22.	apt-get			; interacts with packages
				- update 		; gets our local cache refreshed by getting the table-of-content from internet repo.
				- upgrade 		; upgrade packages excluding the kernel
				- dist-upgrade	; upgrade everything including the kernel
				- install 		; install a package
				- remove 		; remove a package but not its configurations
				- purge	 		; remove a package completely (along with its config files)
		23. apt-cache		; gives info. about packages (works with the cache we downloaded with apt update)
				- search 		; search all info it has about the package
				- show 			; details on the package
		24. aptitude
				- search 		; same as apt-cache search
				- show 				; same as apt-cache search
				- install 			; same as apt-get install
				- safe-upgrade 		; same as apt-get upgrade
		25. dpkg-reconfigure	; will walk you through the initial setup process.


		26. yum 		 	; is super smart and installs packages as well as all its dependencies. 
				- search	; search for package 
				- info		; like apt-cache show
				- install
				- remove
				- update 	; update particular package or all packages on system
				- provides	; <file> says which package provided this particular <file>


16. rpm2cpio And yumdownloader
=>  Helps us to extract files from installation pakages (*.rpm). This comes into play if you accidently delete a
	configuration file (say in /etc/ dir)				
				
		RPM package ---- file.cpio --------------- file1
					  |- description			|- file2
					  |- dependencies			|- ...
					  							|- dir1/
					  								|---- filex
					  								|---- filey

		27. rpm2cpio pkg.rpm > file.cpio	; extracts *.cpio file from RPM package
		28. cpio -idv < file.cpio 			; cpio program extract, including dirs, verbose (-idv) original
											; file structure from 'file.cpio'
		29. yumdownloader pkgx				; downloads an RPM package (here named package named 'pkgx')


17. Intro To Command Line
=>	.bash_history is written as soon as we logout of a session.
	
		30. history -c 								; clears the history
		31. sudo adduser [username] [group_name]	; add a user to the group


18. Environment Variables and common commands
=>		
		32.	env 			; prints all the environment variables
		33. VAR="msg"		; creates a session/shell variable

		34. export PATH=/blah/:${PATH}		; edit an env variable
		35. unset VAR 						; removes an env variable named 'VAR'

		36. cat 						; concatenate files
		37. head -n 5 <file> 			; shows top 5 lines of <file>
		38. tail -n 5 <file>			; shows last 5 lines of <file>
		39. split -l 5 <file> prefix_ 	; splits <file> into many files, each file starting 
										; with prefix_ and storing 5 lines each.

		40.	paste file1 file2			; concatenate files horizontally separated by a TAB
		41.	join						; joins (like database join) common fields in different text files
		42. expand -t 4 file.c			; converts TABS into SPACES - (tabspacing is set to 4)
		43. unexpand -a file.c			; converts a 4/8 spaces into TABS

		44. sed 's/^Abhinav/Abhi/g' file.txt 	; Stream EDitor (s)ubstitutes any occurence of 'Abhinav' at
												; the beginning of line with 'Abhi' and that too (g)lobally
												; in 'file.txt'
		44. echo "Abhi:nav?Thakur$" | tr -d ':','?','$' 	; delete characters ':', '?' and '$' from STDIN and print to STDOUT

		45. find <location> options...	; find files starting from <location>
				-type d/f
				-name  ____		; case sensitive names
				-iname ____		; case insensitive names
				-mtime n		; data modified more than n*24 hrs ago
				-ctime -n		; file's status is changed less than n*24 hrs ago
				-cmin  -60		; changed in last 60 mins

				-exec rm -rf {} \;			; execute 'rm -rf' on results
				-size +100M					; files whose size >= 100M


24. Block Devices v/s Filesystem
=>	Block devices are hardware itself (eg: hard drive) which works on blocks. Filesystem is a logical
	interface to deal with these block devices. Filesystem is something that gives a logical representation
	of the underlying hardware so that we can communicate to files and folders rather than actual 
	storage blocks.
	dd works at a block level.
	TAR (Tape ARchive) works at a filesystem level. It doesn't compress (or save space), it just collects 
	multiple files and creates a single file (name archive) out of it.
	cpio
	gzip and bzip2 are 2 compression algorithms 

		46.	dd if=/dev/fd0 of=/dev/sdd bs=4k		; if is input file, of is output file, bs is block size
													; dd copies all blocks of storage from /dev/fd0 to
													; /dev/sdd by a block size of 4k at a time.
		
		47. tar -cvf output.tar /home/folder		; (c)reate an archive named output.tar from /home/folder
			tar -xvf output.tar 					; e(x)tract an archive named output.tar 

		NOTE : tar's (f) flag should be at last of all the options and just before the <filename>.

		48. find . | cpio -ov > out_file.cpio 		; pipe some particular files as input to 'cpio' which 
													; (o)utputs the compressed file into out_file.cpio
					 cpio -idv < in_file.cpio		; -id flag is used for (i)nput and recreating (d)irectory
													; structure as was there originally before compression.

		50. gzip bigfile.doc 			; compresses bigfile.doc into bigfile.doc.gz (not that efficient)
			gunzip bigfile.doc.gz 		; uncompresses file.doc.gz

		51. bzip2 bigfile.doc 			; compresses bigfile.doc into bigfile.doc.bz2 (efficient but slow)
			bunzip2 bigfile.doc.bz2 	; uncompresses bigfile.doc.bz2


		NOTE : 	If you want to compress a folder with gzip/bzip2 algorithms, you can't do it directly
				with 'gzip' and 'bzip2' (as they only compress files), instead use tar to first convert
				a folder into an archive and then perform gzip/bzip2 compression.
				Or, you can use tar's -z/-j to do both (i.e. first convert a folder into tar archive and
				then perform gzip/bzip2 compression).

		# Using TAR with gzip (*.tgz)
			> tar -zcvf file.tar.gz /home/folder 	; compress a folder via gzip
			> tar -zxvf file.tar.gz 				; extract *.tar.gz

		# TAR with bzip2 (*.tbz)
			> tar -jcvf file.tar.bz2 /home/folder 	; compress a folder via bzip2
			> tar -jxvf file.tar.bz2 				; extract *.tar.bz2


26.	Redirecting STDIN, STDOUT, STDERR
=>	You can redirect multiple file descriptors at once. For eg: you can redirect the STDOUT and STDERR
	to 2 different files by - 

		$ ls bob.txt file.txt > outfile.txt 2> errfile.txt 		; redirecting both STDOUT and STDERR at once

		# Advance REDIRECTION
			$ ls bob > out.txt 2>&1				; first it redirects/connects STDOUT to out.txt. Then,
												; 2>&1 means redirect STDERR to STDOUT, but since STDOUT
												; is already been connected to 'out.txt', all STDERR goes 
												; into 'out.txt' too.

		52. read VAR 							; read a value from STDIN and store it into VAR

		53. grep <pattern> <file> 				; to match a pattern

		54. xargs command <args_from_STDIN>		; useful if a command takes <arguments> rather than using 
												; STDIN as input.

			Lets say ./a.out is a program that accepts command line arguments and we want to give args from
			input file named 'ip_file'.

			eg: $ cat ip_file | xargs ./a.out 	; rm program takes <args> as input to act upon. If we want
												; to give input from another command as argument to ./a.out.

		55. ls | tee out.txt 					; tee redirects STDIN (i.e. output from ls) to both 
												; 'out.txt' and on screen.


28.	Foreground and Background Tools
=>
		57. sleep 1000 &	; '&' ensures that the command is running in the background 
			[1] 3928		; output format-> [job number] and PID 	

		NOTE:	All jobs running in background with '&' specified on cmd line are specific to the terminal
				session we have logged in. If we close the terminal session, all jobs are terminated. When
				you close up the controlling terminal it sends up the HUP signal (short for Hang UP signal
				SIGHUP)	to all the child processes.

		56. jobs			; outputs all the job numbers/state/name and PID's of jobs running 
							; in the background.

		NOTE: 	Use CTRL+z to 'suspend' a currently running foreground job. A '+' sign means the job is
				most recent one and the '-' sign means the job is second most recent one.

		58. fg %1 			; foreground job number [1], if not passed with %1, it runs the most recent 
							; job (marked with a '+' sign) in foreground.
		59. bg %1			; if job number [1] is stopped (suspended), run it as a background process.


		# Protecting Child Processes from HUP signal (SIGHUP)

		60.	nohup [command] &		; redirects the output of [command] to 'nohup.out' file on disk
		61.	disown %2				; disowns job number [2] from the controlling terminal (probably marks
									; it as a children of init/systemd process as daemon)

		# To interact with disowned processes (Use 'screen' program)
		> Press CTRL+A then 'D' to disconnect with a screen.

		62. screen -dr 				; gives us back the disconnect screen


29.	Process Management (Adv.)
=>	
		63. kill -n 9 [pid]			; send SIGKILL (signal no. 9) to PID
				 -l 				; shows list of all signals
		64. killall -n 9 [procname] ; kill a process by its name (all instances of the process)

		# Better one's
		66. pgrep -af sle 			; finds sle* everywhere in the execution string (including process 
									; name and cmd line invokation)
		65. pkill -f sle			; kills all processes naming sle*
		

31. Nice Levels (Priority Levels)
=>	Nice level varies from - 

	-20 						   0							19
	|------------------------------|----------------------------| 
	(higher 					(default)					  (lower
	 priority)					priority 					  priority)

	 -20 nice level consumes most of the processor and is therefore the higher priority and less nicer

	 	66. nice -10  <program>		;  10 : program starts with medium low nice level
	 		nice --15 <program>		; -15 : very high nice level
	 		nice -19  <program>		;  19 : lowest nice level 
	 		nice --20 <program> 	; -20 : highest nice level
	 		<program>				;  0  : default nice level

	 	67. renice 19 -p [PID] 		; reconfigure nice level of PID to 19


32.	Regular Expressions
=> 	grep, egrep (extended grep), fgrep (fast grep)
		68. grep abhi* file.txt 	; find abhi* from file.txt
			ls | grep nam*			; grep for any directory entry whose name starts with 'nam'

				^ 	- beginning of line.
				$ 	- end of line
				. 	- any character
				| 	- or
				[]	- ranges

		69. egrep '<pattern>' file.txt 		; evaluates extended regexes

				egrep '^[a-m]' file.txt 	; line begins with a character between 'a' to 'm'
				egrep '^(P|p)' file.txt 	; line begins with 'P' or 'p'
				egrep '^(P|p)..$' file.txt 	;

		70. fgrep 'patt$' file.txt 			; doesn't evaluate regex at all, will match only for patt$ 


35.	MBR and GPT
=>	Partitioning scheme is changing from - 

		# MBR (Master Boot Record)
		> kind of Table of Content for your harddrive
		> lives on first sector (CHS-001)
		> limited to 2TB
		> limited to 4 partitions (3 primary + 1 extended)

		# GPT (GUID Partition Table)
		> stored in multiple locations in a harddrive
		> any number of partitions

	Firmware is also changing from - 

		# BIOS (Basic Input Output System)
		> only supports MBR (so GPT itself acts like MBR)
		> Sees GPT as a drive with a single MBR partition.

		# UEFI (Unified Extensible Firmware Interface)
		> Native GPT support
		> Usually, the firmware needs to run in legacy mode to support MBR.

	NOTE: Paritioning is just adding chapters to the Table of Content (index) of a book,
		  i.e. to partition table.

		71.	sudo fdisk /dev/sdb				; to partition a drive using MBR 
											; partitioning scheme
			: m (help)
			: p (print partition table)
			: o (create a new empty DOS/MBR partition table)
			: n (add a new partition)
			: l (list known partition types)
			: t (change a partition's sytem id)
			: w (write changes from memory to disk)

		72. sudo gdisk /dev/sdb 			; to partition a drive using GPT
											; partitioning scheme.
			: ? (help)
			: o (create a new empty GUID partition table GPT)	
			: p (print partition table)
			: n (add a new partition)
			: w (write changes from memory to disk)

36.	Formatting Partitions
=>	Filesystems - 

		# Extended File Systems

			##	ext2
			>	max partition - 32TB
			>	no journal
			> 	used with USB, lower write actions 

			## 	ext3
			> 	Max partition 32TB 
			> 	journaled

			## 	ext4
			>	max partition 1EB
			> 	journaled
			> 	speed enchancement and CRC (cyclic redundancy checksum) checking

			##  others include - 
				> BtrFS		- snapshots, compression, auto-defragmentation
				> ReiserFS 	- very space efficient with small files
				> XFS 		- good for large partitions
				> NTFS 		- New Technology FS (Microsoft)
				> FAT32 	- Microsoft
				> ZFS, JFS, Reiser4, HFS+

	Non-Filesystems - 

		# Swap == Pagefile
			> can indeed use a file as swap space
			> usually uses an entire partition as swap space

		73. sudo parted /dev/sdb	; (part)ition (ed)itor to see partitions
			(parted) help print
			(parted) mklabel msdos 	; create a label
			(parted) print free 	; outputs free space available on partition

		74. mkswap /dev/sdbx 		; creates swap on a specific partition of device
			
		75.	mkfs -t ext4 /dev/sdbx	; -t stands for partition (t)ype
			mkfs.ext2 	/dev/sdbx	; create a Filesystem
			mkfs.ext3			
			mkfs.ext4	
			mkfs.msdos
			mkfs.ntfs

		NOTE: mkfs is a frontend to programs like mkfs.ext2, mkfs.ext3 etc.

	Maintaining Filesystems

		76. fsck -N  /dev/sdbx	; checks the kind of partition 'sdb1' is and recommends the 
								; command that could be run based on the guessed part. type.
			fsck -fy /dev/sdbx	; fix all errors found by fsck on partition 'x'.	

		NOTE: Don't use fsck on mount points (mounted devices), use it on devices in /dev dir.

		77. tune2fs	 /dev/sdbx	; change ext2 to ext3 (just by adding a journal)

		78. dumpe2fs /dev/sdbx 	; show all superblocks info

		79. debugfs	 /dev/sdbx	; interactive filesystem editor

		##	XFS filesystems
		>	install 'xfsprogs' package on Ubuntu

		80. xfs_info  	  /dev/sdbx	; shows info of partition 'x'
			xfs_repair	  /dev/sdbx	; checks and fixes problems of partition 'x'
			xfs_repair -n /dev/sdbx	; complete check of filesystem without making changes.
			xfs_check 	  /dev/sdbx	; not recommended


37.	Mount and Unmount Filesystems
=>	To be able to use devices (storage mainly), they need to be attached to the filesystem.
	The directory location where they are attached is known as a 'mount point'.

		81. mount 			; by default shows every device mounted on the filesystem.
			mount -t [type] /dev/sdb /loc 		; mount device 'sdb' at location 'loc' 
												; whose filesystem is of type 'type'
			mount /dev/sdbx /loc
			mount -o remount,rw	/dev/sdbx /loc 	; remount device /dev/sdb with permissions
												; Read-Write at location '/loc'
		82. umount /location 			; unmount device mounted at '/location'
			umount /dev/sdb1 			; unmount device '/dev/sdb1'
		83. fstab						; to permanently mount devices at every bootup.

	/etc/fstab entry - 

		<file system>	<mount point> 	<type> 	<options> 					<dump>	<pass>
		/dev/fd0 		/media/floppy	auto 	rw,user,noauto,exec,utf8	0 		0
	or 	UUID=a87... 	/				ext3 	defaults		 			0 		1


38.	Quotas on Harddisks
=>	To limit the use of hardware devices, we can asign quotas on it. They are of 2 types - 

		# Hard limit
		> It is the ultimate amount of resource the user can use. 
		> A barrier that user cannot cross.

		# Soft limit
		> User can pass the soft limit but only for a fixed amount of time (1 week by default),
		  otherwise you're gonna loose your work saved under the extra space.
		> Whatever be your hardlimit, you have to get back into your soft limit within a
		  week (set by default).

		<file system>	<mount point> 	<type> 	<options> 					<dump>	<pass>
		/dev/fd0 		/media/floppy	auto 	defaults,usrquota,grpquota	0 		0


		84.	sudo apt install quota
			sudo quotaoff	/dev/sdbx 			; turn quota off (stops monitoring)
			sudo quotacheck -cug /dev/sdbx		; (c)reate (u)ser (g)roup quota files for device
												; aquota.user and aquota.group
			sudo quotaon	/dev/sdbx			; start monitoring on device /dev/sdbx
			sudo edquota -u username /dev/sdbx	; edit/configure quota monitoring for device
			sudo repquota 	/dev/sdbx			; gives report for real time monitoring 


40.	File Ownership & Permissions
=>	umask is the default mask for file creation which specifies the permissions that will be
	subtracted each time a new file is created.

	NOTE: execute permissions on directories mean that they can be switched into (i.e. cd dir_name).
		  write permission means new files can be created as directory entries inside the folder. 

		85.	sudo chgrp root file.txt 		; change group belonging of file.txt
		86.	sudo chown root file.txt 		; change owner of file.txt

		87. sudo chmod 0777 	  file.txt 		; changing permissions on a file
			sudo chmod ugo+rw file.txt 		; add read/write permissions to (u)ser, (g)roup
											; and (o)thers.
			sudo chmod g-rw   file.txt 		; take away read/write permissions from group.
			sudo chmod u+r,g-x,o+x file.txt ; 

	Starting creation permissions
		> files 		- 0666 	
		> directories	- 0775

	suppose umask is 002, then - 
		0666 (starting creation permissions)
	  - 0002 (umask)
	  -------
	    0664 (file created with this permission)
	  -------

	defaults of umask in files - 
		$ /etc/profile
		$ /etc/bashrc
		$ /etc/login.defs


42. SUID, GUID and Sticky Bit
=>  On directories permissions mean differently as that on a file - 
	Read 	: person is allowed to view directory entries
	write	: person is allowed to create/delete a directory entry
	execute	: person is allowed to parse/move in and out of the directory
  
		# SUID 
		> file   - file executes with permissions of file's owner.
		> folder - no affect

		# GUID
		> file   - file executes with permissions of file's group field. 
		> folder - new files have group membership of folder.

		# Sticky Bit
		> file   - exe's with sticky bit set stay in memory even after they finish executing. Not
				   used much keeping modern memory management subsystems in mind.
		> folder - only owner can delete files.

					 <owner> <group> <others>
	suid bit set : - rws     rw- 	 r--
	guid bit set : - rwx 	 rwS 	 r--
	sticky bit   : - rwx 	 rw- 	 r-t

	NOTE: If you set suid, guid bit to a field that has e(x)ecute permissions set, a 's' marks 
		  as the suid/guid bit. If e(x)ecute permissions are not set, a 'S' is placed instead.

		88. sudo su -l username 	; login to username

		89. chmod u+s file.txt 		; set suid bit to file.txt 
		    chmod g+s file.txt 		; set guid bit to file.txt
		    chmod o+t folder 	 	; set sticky bit to file.txt
		    chmod o-t folder 		; remove special bit (sticky) from folder

		SPECIAL bits in octal 
			> 4	: SUID bit 
			> 2	: GUID bit
			> 1 : sticky bit

			chmod 6777 file.txt 	; first 6 is (SUID + GUID bit set) 
			
		90. xdg-open webpage.html 	; automatically choose appropriate application to read
						; webpage.html file (i.e. open up default browser)
						

42. Hard Links and Symbolic (soft) Links
=>  Hard Links are multiple files that point to the same physical location on a hard drive. They 
	point to the start of file (i.e. inode) on hard disk. 
	Hard links cannot be created between 2 physical storages.

	Soft Links aka symbolic links are 'files that point to files' (kind of shortcuts on Windows).
	They can be created between 2 separate storage devices.

		91. ln file1 hardlink_file 		; create a hardlink_file of 'file1'
		92. ln -s file1 shortcut_file 	; create a symbolic link of 'file1'
			ls -li ./					; cross-verify the inode number of file1 and hardlink_file
										; they must be identical.


45. Find and Locate
=>	'find' searches the filesystem in real-time whereas 'locate' command relies on a database that it
	maintains on a per day basis.
	Before locating the newest files created, update database used by 'locate' by 'updatedb'

		93. which    <binary_name> 		; find the location of 'program_name'
		94. whereis  <binary_name>		; find the location of 'program_name' and 'manual'

		95. find <location> options...	; find files starting from <location>
				-type d/f
				-name  ____		; case sensitive names
				-iname ____		; case insensitive names
				-mtime n		; data modified more than n*24 hrs ago
				-ctime -n		; file's status is changed less than n*24 hrs ago
				-cmin  -60		; changed in last 60 mins

				-exec rm -rf {} \;			; execute 'rm -rf' on results
				-size +100M					; files whose size >= 100M

		96. sudo updatedb 				; update the database that 'locate' program uses
			sudo locate  <file>		 	; locate a file on filesystem  


46.	User Profiles and System Profiles
=>	After the system starts, it loads up some configurations by executing configuration 
	scripts for user depending upon what type of shell access is being performed. There
	are mainly 2 types of shell accesses that are provided - Login and interactive shell.
	Differences between them are based on environment setting process.
	Interactive shell 

		*	Login Shell
		=>	This includes shell like ssh. A login shell will look for scripts in the below
			given order -

			1. /etc/profile 
					-> /etc/profile.d/*
			2. /etc/bash.bashrc or /etc/bashrc	
			2. /home/user/.bash_profile 	# Runs the first one found of these 3 scripts
					or	 /.bash_login
					or	 /.profile
			3. /home/user/.bashrc

		* 	Interactive Shell
		=>	This includes shell spawned by us via terminal launcher. It executes - 

			1. /etc/bash.bashrc
			2. /home/user/.bashrc

		97. source ./script_name		; it loads the script in our current environment and	
			. 	   ./script_name 		; executes it rather than creating a child process.


47.	Shell Scripting
=>	#!/bin/bash 		# shebang 'bash' binary
	
	VAR=$(ls -l) 		# $() is command substitution, means result of the command is stored
						# in variable VAR

	read -p "Are you the devil ?" ANSWER 		# prompts the string and waits for user input
												# storing it in variable $ANSWER
	if [ $ANSWER == "YES"]
	then
		# stuff
	else 
		# other stuff 
	fi

	for i in {1..10};		# for VAR in some_sequence;
	do
		# some stuff repeatedly
	done

	VAR=1
	while [ $VAR -lte 10 ] 	# while #VAR is less than or equal to 10 (termination cond.)
	do
		let VAR=VAR+1
	done


49.	SQL Data Management
=>	Here <FIELD> means field name and <TABLE> means the table name to be queried.

		97. mysql -u <username> -p <database_name>
		
		# Displaying Tables
		--------------------
		mysql> SHOW TABLES;

		# Displaying Columns 
		---------------------
		mysql> SELECT * FROM <TABLE> 			# show all fields in the table
		mysql> SELECT * FROM <TABLE> 
			   WHERE <FIELD> = "JADOO";
		mysql> SELECT <FIELD> FROM <TABLE> 		# display <FIELD> from table with bla bla..
			   WHERE <FIELD1> = "X" AND <FIELD2> = "Y";
		
		# Grouping and Ordering Rows 
		-----------------------------
		mysql> SELECT * FROM <TABLE>
			   ORDER BY <FIELD1>;
		mysql> SELECT * FROM <TABLE>			# removes duplicate entries from <FIELD1>
			   GROUP BY <FIELD1>; 				# and represent it by a single uniq entry 
												# used to see how many different values are	
												# present in <FIELD1>
		# Inserting a Row 
		-----------------
		mysql> INSET INTO <TABLE> 				
			   (<FIELD1>, <FIELD2>, <FIELD3>) VALUES 
			   (<VAL1>, <VAL2>, <VAL3>);		

		# Deleting a Row 
		--------------------
		mysql> DELETE FROM <TABLE> 
			   WHERE <FIELD1> = "X";

		# Modify Table 
		--------------
		mysql> UPDATE <TABLE>
			   SET <FIELD1> = "NEW_VALUE"
			   WHERE <FIELD2> = "VALUE2";

		# Joining 2 Tables
		------------------
		mysql> SELECT * FROM <TABLE1> JOIN <TABLE2>
			   ON <TABLE1>.<COMMONG_FIELD> = <TABLE2>.<COMMON_FIELD>;

		-> Above command displays 2 tables joined together based ON a <COMMON_FIELD>.
		   (displaying all the fields from both tables)

		mysql> quit



50.	X11 (Xorg) Configurations
=>	X11 is the X Window system that provides GUI on *NIX systems. Using xhost command, we can 
	configure our machine to allow remote GUI connections.

		98. xwininfo 			; select a windows to view info 
		99. xdpyinfo			; gives ton of info to us.
		
		100. xhost - 			; enable access control, don't let external host connect 
			 xhost + 			; disable access control, let external hosts connect to our GUI
			 xhost +10.1.1.4	; disable access control, allow only the host at 10.1.1.4 to 
			 					; connect to our us via GUI.
			
			-->  Onremote host, set the $DISPLAY environment variable to the IP address of
				machine on which we want to take GUI access to (which is having access control
				disabled). 
				$ export DISPLAY=<remote_machine_IP_address>:0.0		
			--> Read $ man Xsecurity


51.	Display Managers
=>	Its the graphical interface that you see when you system boots up and prompts you for a password.
	eg: XDM (original), KDM (supported by KDE), GDM (supported by GNOME desktop environment),
		lightDM (explained below).

		# Configuration Files for display Managers
			> /etc/gdm3	
			> /etc/lightDM
			> /etc/kdm

		# Disabling Graphical Manager
			* CentOS 
			> sudo telinit 3 		# CentOS : disabling graphical manager - init runlevel to 3

			* Ubuntu
			> sudo vim /etc/default/grub
				[-] GRUB_CMDLINE_LINUX_DEFAULT=""
				[+] GRUB_CMDLINE_LINUX_DEFAULT="text"
			> sudo update-grub
			> sudo reboot


52.	Accessibility (Universal Access feature)
=>	AccessX (keyboard options)


53. Managing Users and Groups
=>	
		101. useradd <username>			; create a user
				-d /home/directory
				-m 					; create homedir
				-s /bin/bash		; specify default shell
				-G 					; additional groups
				-c "My name"		; comment 
		102. usermod					; change/modify account attributes
				-L 					; lock/disable account
				-U 					; unlock/enable account 
				-aG 				; add to group
		103. userdel 
				-r 					; delete the home folder along with the user account

		104. groups <username>		; see what all groups is the <username> into
		104. groupadd 				; add current user to <GID>
				-g <GID> <GROUP_NAME> 			
		105. groupmod
		106. groupdel

		107. sudo passwd <username>		; change <username>'s password
		108. id <username>				; details about <username>


54.	Password, Group and Databases
=>	
		$ cat /etc/passwd
		kratos:x:1000:1000:kratos,,,:/home/kratos:/bin/bash

		Fields 
		------
		1. kratos		: username
		2. x 			: password (in /etc/shadow encrypted via one way hashing algo.)
		3. 1000 		: UID
		4. 1000			: User's primary GID
		5. kratos,,,	: comment field (usually always there to store user's name)
		6. /home/kratos : user's home directory
		7. /bin/bash 	: user's shell

		$ cat /etc/shadow
		kratos:$6$fC8lBpHIl3dOmUnq$7iPZVGvZGYr71ESF4anDpnUHlFrIYvRSNkfZn.6s6coWTGgRyjYTCwrXGiGCCCjK4fycSTpKHokZeBROqInXg/:18517:0:99999:7:::

		Fields
		------
		1. kratos 		: username
		2. $6$fC...		: encrypted hash of password
		3. 18517		: when was the password last changed (days since 1st Jan, 1970)
						: 
		4. 0 			: minimum password time. This many days has to go by before a user
						: can change the password
		5. 99999 		: how long will the password be valid before it expires
		6. 7 			: system will warn before 7 days that the password is going to expire

		109. chage	-l <username>		; show/decipher the /etc/shadow file into human readable 
					-E 2021-06-21		; account expires on this date


55. Job Scheduling
=>	With 'At' (one time scheduling) and Cron (repetitive scheduling)

		* * * * *		<command_to_execute>
		| |	| | |
		| | | | |----> day of week  (0-7)  (0 and 7 are Sundays)
		| | | |------> month		(1-12)
		| | |--------> day	 		(1-31)
		| |----------> hour 		(0-23)
		|------------> minutes		(0-60)

		@reboot 			--> On reboot
		02 13 *  *  * 		--> 1:02 PM daily (every day, month, day of week)
		01 06 18 *  * 		--> 18th of every month at 6:01 AM
		05 *  *  6  0 		--> 5 minutes past every hour, each Sunday in June. 
		1,6,12 * * * * 		--> 1, 6 and 12 minutes every hour
		6  3  *  *  1-5		--> Weekdays at 3:06 AM
		*/5 *  * *  *		--> every 5 minutes 

		110. cronttab -e 		; edit cron table
		111. at 17:	00
			 at> echo "Run at 17:00 Hrs"
			 at> <EOT>
		111. at now + 5 minutes
			 at> echo "[+] Hello after 5 minutes issuing the command using at" 
			 at> <EOT>
		112. atq 			; shows all the commands queued using 'at'
		113. atrm 1 		; removes the 1st command queued using 'at'

		##	Anacron
		=>	If a cron.daily, weekly or monthly was missed, it notices at boot.
			timestamp's in /var/spool/anacron


57.	Timezone (Locale and Internationalization)
=>
		114. tzconfig			; depricated
		115. tzselect			; select a timezone 
		
		Add the below line to '.profile' and changes will be made for us <username>
		[+] TZ='Asia/Kolkata'; export TZ

		# To make system wide changes
		1. edit /etc/timezone.
		2. copy /usr/share/zoneinfo/<select_your_timezone> to /etc/localtime.

		$ vim /etc/timezone		; change timezone here
		$ /usr/share/zoneinfo 	; location that stores binary files for  timezones
		$ /etc/localtime 		; actual file responsible to set up time for the whole system 
								; It is a copy of /usr/share/zoneinfo/Asia/Kolkata

		# Language 

		116. locale 
		117. export LC_ALL="en_US.UTF-8"		; overrides everything

		# Character Encodings
		> ASCII (128 chars all english txt)
			|---> ISO - 8859
			|---> UTF-8  (Universal Transformation Format) ---> Universal Standard

		118. iconv -f ASCII -t UTF-8 /etc/shadow 	; convert all characters of /etc/shadow 
													; (f)rom ASCII (t)o UTF-8 


58.	Maintaining System Time 
=>	
		119. date 						; shows date/time as per system clock
			 -s "03/19/2015 12:20:47"	; set system date/time 
		120. sudo hwclock 				; queries hardware battery clock for current time
			 sudo hwclock --set 		; set hardware clock
			 --date=03/19/2015 12:20:00"
			 --local					; to switch to local time

			 sudo hwclock -u -w 		; set time in UTC -w will sync the system time to 
			 							; hardware clock

	# NTP server (Network Time Protocol)
		Website : www.pool.ntp.org 		; keeps track of all the NTP servers over the globe
										; choose the one closest to you for your NTP server

		121. sudo ntpdate <url> 		; will set the system time to whatever the reply is
										; from <url> (0.us.pool.ntp.org0)
			 sudo hwclock -w 			; sync hw clock to system clock

		122. sudo service ntp start 	; start the NTP daemon
							  status	; query NTP daemon status
							  stop 		; stop NTP daemon
							  restart 	; restart NTP service
			
		123. sudo ntpq -p 				; query NTP servers and print server info.
			
			> /etc/ntp.conf : configuration file for NTP daemon

			> if NTP service is not present: sudo apt-get install ntp


59.	System Logging (/etc/rsyslog.d)
=>	Any daemon process sends its log to the system logger program (syslog server) which 
	dumps the log based on 'facilities' and 'priorities' and 'action'.
	Some system logging programs - syslog, rsyslog, systemd-ng

		facilities:	auth, user, kern, cron, daemon, mail, local1 to local7
		priorities: emerg/panic, alert, crit, err/error, warning/warn, notice, info, debug 

	Any log message which is sent by an application to 'syslog server' will tag itself to-
		> facility
		> priority
		> action

		facility.priority 		action
		----------------------------------
		user.info 				/var/log/user.log
		kern.panic				notify on <username>'s on screen
		mail.info 				@192.168.1.15 (send all mail facility's info priority &
								above to this IP address which is of log server's address)
		mail.=info				/var/log/messages (sends only info messages)
		*.*						-/var/log/messages (sends everything that doesn't fit above
								to this log file)

		mail.=info sends only 'info' priority messages while 
		mail.info  sends all priority messages (including notice, warn, err, crit,
		alert, panic)

		NOTE: Kernel logging is done by a separate daemon named - klogd that uses the same
			  configuration file as of syslog.
		NOTE: The '-' in '-/var/log/messages' tells the syslog program to use cache to store
			  log messages rather than writing directly to disk which is a bit costly.
		
		** At server side 
		=> If you want to have your own syslog server, then you have to add a flag to syslog server
		   program at its bootup.

		   In /etc/default/rsyslog - 
		   		[-] RSYSLOGD_OPTIONS=""
				[+] RSYSLOGD_OPTIONS="-r" 		; to listen for (r)emote people to send it messages.

		** Systemd Journaling Sub-system
		=> Systemd has its own binary logging system that logs messages in binary form rather
		   than TEXT based logs. We cannot grep from these binary logs. The only way we can read
		   these binary logs is through 'journalctl' program.

			124. journalctl MESSAGE=
		    
			/etc/systemd/journald.conf - to configure systemd logging.
			

		# TESTING
		> Use 'logger' program to make log entries (send messages to rsyslog daemon), use it to
		  test/check where the logs are going.

			125. logger local4.crit abhinav is here 	; send a message "abhinav is here"
														; to rsyslog daemon (system logger program)
														; with facility = local4
														; and priority level = critical

			126. logrotate <config_file>				; rotates, compresses (backup) and mails 
														; system logs
				 configuration files for logrotate program
				 	--> /etc/logrotate.d/
				 	--> /etc/logrotate.conf


60. Mail Transfer Agents (MTA's)
=>	Sendmail - popular email daemon (like qmail, exim, postfix)					 
	Use '/etc/aliases' file to forward root's emails to another user. 
	To forward mails on individual basis, create a file ~/.forward that contains
	the email address or <username>@<host> to forward all messages of current user to.

		127. mail root -s "subject is fucked" "my body"


61. Managing Printers (using CUPS) 
=>	CUPS (Common Unix Printing System) config.

		goto CUPS interface --> http://localhost:631      or,
		configure it here   --> /etc/cups/<config_file.conf>

		128. lpr -P<Printer_name> doc.txt		; (r)ead and send a file to printer
		129. lpq -a 				; (q)uery , show all printing jobs
		130. lpc status 			; status of printer
		131. lprm <job_no> 			; (r)remove print jobs
			 lprm -PHP_Inkject -	; removes all jobs of HP_Inkject printer

		# Troubleshooting

		132. cupsenable  <printer_name> 	; enable printing
		133. cupsdisable <printer_name> 	; disable printing

		134. cupsaccept <printer_name>		; start accepting jobs
		135. cupsreject <printer_name>		; start rejecting jobs(can't send print jobs)

-----------------------------------------------------------------------------------------------------

62.	NETWORKING
	----------
=>	Due to NATing performed by our home routers (access points), private networks can be 
	created. Every private network will have a subnet mask (eg: 255.255.255.0) which can
	be represented in a CIDR notation (which is just a count of 1's in subnet mask).

	IPv4 		- 32  bit value : 4.2 billion devices, around 3.7 billion is usable
	IPv6 		- 128 bit value : shorthand notation is used to represent it
	Subnet mask - A series of 0's followed by 1's that divide an address into 
				  network address and host address (255.255.0.0) has 2^16 hosts.
	CIDR 		- just a count of 1's in the subnet mask. Eg: 255.255.0.0 can be 
				  represented as /16 in CIDR notation.
	Gateway 	- a device that is used to connect 2 networks/subnetworks or a device or
				  a device having 2 or more interfaces (network adapters) such that it
				  connects 2 different networks.

	# Common Ports (/etc/services)
	20, 21 	- FTP (data + control)		
	22 		- SSH 
	23		- telnet
	25 		- SMTP (mail program)
	53		- DNS
	80 		- HTTP 
	110 	- POP3
	123 	- NTP
	139 	- NetBIOS (Microsoft's)
	143 	- IMAP (mail server port)
	161,162 - SNMP
	389 	- LDAP 
	443 	- HTTPS
	465 	- SMTPS
	636 	- LDAPS
	993 	- IMAPS
	995 	- POP3S

		136. hostname -I 		; identify IP address of a machine

		137. ifconfig					; list all network interfaces (IP, subnet mask, 
										; broadcast, MAC address etc)
			 ifconfig eth0 192.168.1.1 			; change the IP address to eth0 interface	
			 ifconfig eth0 netmask 255.255.0.0	; change the newmask of eth0 interface
			 ifconfig eth0 down			; take eth0 interface down
			 ifconfig eth0 up  			; turn eth0 interface up
			
		Below 2 commands only work when the server uses network configuration files
		138. ifdown eth0		; turns eth0 interface down 
			 ifup 	eth0		; turns eth0 interface up

		139. iwconfig	 		; configure wireless network interfaces

		140. route 				; shows the routing table (informing about the exit points of our
								; network traffic). If there are more than 1 NIC present on machine
								; and machine is talking to 2 different networks, we can see it
								; listed in routing table (enumerating sub-networks).
			 route add default gw 192.168.1.2 		; set up address of default gateway.

		141. traceroute google.com		; lists down all the hops to the destination google.com 
		142. tracepath google.com 		; pings all the hops till the destination google.com
		
		143. dig google.com				; resolves domain name into its IP address using default DNS
			 dig @8.8.8.8 google.com	; performs domain name resolution using 8.8.8.8 as its DNS.

		144. ping <hostname/IP>	; send ICMP packets to <hostname> or <IP address>
		145. arp -a				; ARP talks to IP address and asks for MAC address to which
								; it talks to. It is basically used to find MAC addresses/ IP
								; address of gateway or any device that our system is talking to.
		146. netstat -tuna		; network status of system
					-r 	 		; show kernel routing table (similar to 'route' cmd)
					-lp 		; show all listening connections along with process names listening
		
		147. nmap -T4 -A -p- <TARGET_IP> 	; scan an external network for open ports and services.

		NOTE: In netstat output, 0.0.0.0:631 means every interface (both eth0 and loopback) is
			  listening on port 631 (probably CUPS printer service). 

				
	### DNS (Domain Name Server or Nameserver)
	=>	Use command called 'dig' to query local and remote DNS. Local DNS is basically '/etc/hosts'
		file.

			* /etc/nsswitch.conf 	; configure name (domain name) resolution order (i.e. between
									; local and remote DNS)


	### In CentOS server - 
		$ /etc/sysconfig/network-scripts 		; dir storing configuration scripts for 
				|---> ifcfg-eth0				; network adapters.
		$ /etc/sysconfig/network				; a file to setup Default Gateway.

	### In Ubuntu server - 
		$ /etc/network/interfaces				; configure network interfaces
			
			open /etc/network/interfaces:
				# Configure/setup network interface (NIC) named 'eth0'
				auto eth0
				iface eth0 inet static 				# specifying a static IPv4 address
				address 192.168.202.131				# specify a static IP for the machine
				netmask 255.255.255.0				# specify a subnet mask
				gateway 192.168.202.2 				# specifying gateway address
				dns-nameservers 8.8.8.8				# specifying DNS server
				dns-nameservers x.x.x.x 			# specifying another DNS server

		-> To setup eth0 to dhcp, enter:

			open /etc/network/interfaces:
				auto eth0
				iface eth0 inet dhcp

		$ /etc/hostname			; edit this file to change hostname (also edit in /etc/hosts)
		$ /etc/hosts			; local DNS for our system consulted for name resolution
								; even before it reaches out to DNS server present on 
								; public network
			open /etc/hosts:
				127.0.0.1 	localhost
				127.0.1.1 	<hostname> 			<--- This should match to our hostname in 
													 /etc/hostname
				192.168.1.10	myserver 		<--- ping myserver resolves to this IP address.

-----------------------------------------------------------------------------------------------------

68.	Basic Security
=>	
		# Check for suid/guid binaries
		> find / -perm	-u+s		; look for suid binaries
						-g+s		; look for guid binaries

		# Check for open ports
		> netstat -tuna 

		# Editing Sudoers file
		$ groups 
		kratos adm cdrom sudo dip plugdev lpadmin lxd sambashare vboxsf
		148. visudo /etc/sudoers

			%sudo	ALL=(ALL:ALL) ALL		# the '%' is for groups
			bob		ALL=(ALL:ALL) /bin/ls	# bob user on all hosts, as all 
											# user:groups can execute /bin/ls
		
		->	means anybody in the sudo group can function on 'all' host (ALL=).
			they can do things as 'all' people and 'all' group (ALL:ALL) and the
			things they can do is 'all' commands (ALL).
			ALL means any command that can be performed


69.	Services and Security
=>	Playing with services depends upon which initialization (init) system your 
	machine is running on. 
	Superservers (aka service dispatcher) named 'xinetd' or 'inetd' is a daemon 
	used to manage other servers or services.

		# System V system 
			* Disable a service
				148. chkconfig 	  	<service_name> off 		# usually found in Red Hat variants
				149. sysv-rc-conf 	<service_name> off		# usually found in Debian variants
			
		# Upstart system
			* Disable a service 
				150. update-rc.d	<service_name> remove

		# Systemd system
			160. systemctl disable <service_name>
			161. systemctl status  <service_name>
			162. systemctl start   <service_name>
			163. systemctl stop	   <service_name>
			164. systemctl restart <service_name>

	
70.	User Limits
=>	You can limit system resources both for individual users and system-wide.

		165. nproc	 			; see the number of processing units available
		166. who 				; shows who is logged in
		167. w  				; shows who is logged in and what are they doing
		168. last				; shows a listing of last logged in users 
		165. ulimit -a 			; lists all limits on a particular user
			 
			 To modify the limits use -  
			 	$ ulimit -<flag> <value>
				$ ulimit -c 1000		; limits the size of ET_CORE binary to 1000 bytes.

			# Setting system-wide limits
			> In file '/etc/security/limits.conf', 'soft' limit means user will get a warning
			  whereas a hard warning means the operation absolutely cannot be performed.



71. Encryption and Signing 
=>	Talking cryptography, a pair of keys is generated known as public key and private key;
	both of which are mathematically related to each other.
	
	In encryption, public key is used to encrypt a data that only its respective private key
	can decrypt.
	In signing,   private key is used to encrypt a token that only its respective public key
	can decrypt. 

		Public key	- our public key should be available all around the globe so that people
					  can send us encrypted messages.
		Private key - It is our secret key that can decrypt any encrypted data sent by anyone
					  using the respective public key (remember private and public keys are
					  generated in pair).


	* Signing (verifying identity)
		Signing means providing 'proof of identity'. It works on the principle below -

		PUBLIC KEY CANNOT DECRYPT ANY DATA OTHER THAN THE ONE ENCRYPTED BY ITS PRIVATE KEY PAIR.

		If on the other hand, if we use private key to encrypt data (lets say a token), then only
		its respective public key will be able to decrypt it. Since, the only data public key can
		decrypt is the one that is encrypted by its respective private key, we can 100% verify the 
		identify of the person holding the private key.
		This encryption by private key is known as 'signing' and works as a method to verify 
		identities on internet.

		Basically, if a public key can decrypt some data that means the data is encrypted by its
		private key pair.

	
	* SSH 
		$ ssh <username>@<hostname>

		A first connection to any unknown machine says - 

			"The authenticity of host 'x.x.x.x' can't be established"

		It is because, our machine doesn't have its public key. If we say 'yes', then in our 
		'~/.ssh/known_hosts' gets stored the public key of 'x.x.x.x' machine (the remote machine
		we are trying to connect to).

	Public key is present at - /etc/ssh/ssh_host_rsa_key.pub 		# i.e. all *.pub

	
	* Creating and using Keypairs
	-> If someone has our private key, they will be able to login anywhere our public 
	   key is installed.

		166. ssh-keygen
			 Enter passphrase: 

		NOTE: If we have a passphrase, we have a program called 'ssh-agent' running on our
			  server which stores the entered passphrase in memory so that we don't need to 
			  enter it again and again.
		
		--> After the key is generated, check into default location - ~/.ssh which has - 
				> id_rsa 		(generated private key using RSA)
				> id_rsa.pub	(generated public key using RSA)

		167. ssh-copy-id -i ~/.ssh/id_rsa.pub  <SERVER_IP>	
												# We want our public key to go to the server.
		

	* Encrypting with GPG 
	-> 
		168. gpg --gen-key
			 gpg --list-key
			 gpg --export <username> > /tmp/mykey.pub
			 gpg --import /tmp/mykey.pub		# on server side
			 gpg --out from_server --recipient <username> --encrypt <secret_file..txt>
			 gpg --out from_server --decrypt /tmp/<data_file>
