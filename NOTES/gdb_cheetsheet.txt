		-=-=-=-=-=-=-=-=-=-=-=-=-=-=-	GDB NOTES	-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

## DEBUGGERS
	- GNU GDB 
	- Intel Debugger (IDB)
	- SoftIce (kernel debugger)
	- WinDBG


*  Compile & Load in gdb
=>	
	$ gcc -o main main.c
	$ gdb -q main		# -q flag for silent(quiet) analysis, don't show welcome message
	Reading symbols from delete...(no debugging symbols found)...done.


## Debugging Symbols ?
=> They are information about variables, functions etc. which the debugger requires for a better 
   understanding. Debugging symbols can be a part of binary as well as a separate file.	You need
   to explicitly mention at the compile time that you want to include debugging symbols.

	Debug Symbol file types:
		- DWARF 2
		- COFF
		- XCOFF
		- Stabs

   --> GCC uses:
	 '-g'    - option to include debugging symbols and
	 '-ggdb' - option for GDB specific symbols

---------------------------------------------------------------------------------------------------------------


### WHAT'S UP With SYMBOL FILES


##	GDB COMMANDS

>	list					# Lists the source code typically from where the main function starts
							# it is useless if you don't have the source code because gdb itself
							# haves a look at the source_code.c file in the directory to list 
							# source code.
>	list 1, 50				# Lists source code from line number 1 to line number 50
>	info functions			# Lists all the local functions added as a part of debug symbols (-g
							# flag) separately. If debug symbols are not present then local names
							# of functions will be present but they will be present in "Non-debuging
							# symbols:" section.
>	info sources			# To list all the source code files(only for debug symbols added file)

@@	For global and static variables
	>	info variables 					# Prints only 'global' and 'static' variables (not local)
@@	For local variables constituents
	> 	info locals						# Prints local variables in the current stack frame
	>	info scope 						# Press TAB to list all the scopes
	> 	info scope func_name			# lists all variable details in function scopes

>	maint print symbols file_to_store	# dump the symbols into a separate file



##	RIPPING SYMBOLS OFF A BINARY
	
		$	objcopy --only-keep-debug	binary_with_debug_symbols new_file_containing_debug_symbols
		=>	To look at debug symbols of a file 
			objcopy is a bin util that copies the debug symbols from a binary to another file


##	STRIPPING SYMBOLS OFF A BINARY (Good for security perspective)
		
		$	strip --strip-debug --strip-unneeded binary_to_strip
		=>	This command removes debugging symbols off any binary_file (w/o --strip-unneeded flag).
			With --strip-unneeded flag, it remove everything apart from what the binary must have
			to load and work properly (try 'info variables' with it, you'll notice that the global
			and static variable names are also removed).


##	ADDING DEBUG SYMBOLS
	>	symbol-file debug_symbols_filename		# gdb reads debug symbols from a file manually.
												# Loads the symbol file into gdb	
	$	objcopy --add-gnu-debuglink=debug_symbols_filename stripped_binary	(into which you want to
																			 add debug symbols)


--------------------------------------------------------------------------------------------------------------


SGDE - 3 (INSPECTING SYMBOLS WITH NM)


##	NM
=>	'nm' lists symbols from object files.

		$ nm -n ./binary_file					# -n flag to get sorted order o/p with respect to address
												# Use -S flag to get 'size' info about symbols
		08049f18 	 d 		 __CTOR_END__										
		08048474	 T 		 AddNumbers			# specifies that AddNumbers is at 0804874 virtual address
												# of Text section.
		.
		.
		.
		Virtual		Symbol 		Symbol
		Address		type 		Name
		 
	->	Lowercase is local symbol
	->	Uppercase is External


##	SOME MOST COMMONLY USED SYMBOLS INCLUDE
=>	
		- A 	: 	Absolute symbol
		- B 	:	In the uninitialised data section (.bss)
		- D 	: 	In the initialised data section (.data)
		- N 	: 	Debugging symbol
		- T 	:	In the text section (.text)
		- U 	: 	Symbol undefined right now


----------------------------------------------------------------------------------------------------------------


SGDE - 4 (SYSTEM CALL TRACING WITH STRACE)


##	STRACE
=>	Trace all System calls made by the program executable, i.e. it makes te syscall monitoring happen.
	With strace, we can also run interpreted language scripts like script.py 

		$ strace ./executable args
			- "-o" output_file
			- "-t" timestamp
			- "-r" relative timestamp


##	$ strace -e write,read,exit,open,connect,socket ./binary args		# To filter out only a list
																			# of syscalls
	$ strace nc google.com 80		# example
	$ sudo strace -p process_id		# Attaching strace to a running process
	$ strace -c program_name		# prints various statistics of syscalls		


----------------------------------------------------------------------------------------------------------------


GDB  - TUI (Text user interface)


>	ctrl-x-a						# move from text mode to tui mode
> 	ctrl-x-1						# show source
> 	ctrl-x-2						# show regs
> 	ctrl-l							# To reconstruct any j
>	layout asm						# initialize asm-source windows
>	layout regs						# initialize register window  
>	tui regs float					# To have FPU's view rather than general purpose regs
>	tui regs general				# To have general purpose regs view in reg windows
>	ctrl-p							# To go to previous commands (while in tui mode) 


----------------------------------------------------------------------------------------------------------------

SGDE - 5 (BREAKPOINTS, EXAMINING REGISTERS AND MEMORY)

	
##	BREAKPOINTS
=>	These are set to freeze the flow of program at a point which allows us to analyse memory,
	registers etc.
	Setting up breakpoints has MULTIPLE OPTIONS-
			- break *address
			- break function_name
			- break line_number


##	GDB COMMANDS

>	break main						# sets breakpoint at function named main
> 	break *main+14					# sets breakpoint at line number <main+14>
>	break *0x8048000a				# sets breakpoint at address 0x8048000a
>	info breakpoints 				# To list breakpoints along with their numbers				
>	disable 1						# disables breakpoint corresponding to number #1
>	enable 1						# enables breakpoint 1
> 	delete 1						# deletes the breakpoint 1
> 	info registers 					# gives current state of registers
> 	info registers all 				# gives info about complete set of registers including 
									# FPU(x87), MMX etc.
> 	help x 							# gives "how to use" information
> 	print argv[1]					# printing the data at location argv[1] as a string
> 	x/s argv[1]						# examines/decodes the data at argv[1] and prints it 
									# as string.
>	x/i 0x8048000a					# examines/decodes the instruction at address 0x8048000a
>	x/10i 0x8048000a				# decodes 10 instructions starting from addres 0x8048000a
>	x/10xw $esp						# prints out 10 hexadecimal words from value at esp reg.
> 	disassemble main 				# objdumps the function main.
>	continue 						# resumes the program until it terminates
> 	si [N]	 						# short for 'stepi' (step assembly instruction)
> 	step [N]						# step 'N' next source code line (enters into subroutine
									# if subroutine is called)
> 	nexti [N]						# steps 'N' instructions but proceeds to subroutine calls
>	next [N]						# step 'N' source code lines, but if the line calls any 
									# subroutine, unlike step it does not enter the 
									# subroutine, rather treats it as a single source line.


---------------------------------------------------------------------------------------------------------------	


SGDE - 6 (MODIFYING REGISTERS AND DATA IN MEMORY)


##	GDB COMMANDS

>	set {char} 0xbffff7e6 = 'B'			# Interpret the value at 0xbffff7e6 as a charecter and set
										# it to 'B'.
>	set {char} 0xbffff7e6 = 65			# sets the memory location to ASCII value of 65 i.e. 'A'	
>	set {char} ( 0xbffff7e6 + 1) = 65	# sets the next byte also to 'A'
>	set $eax = 10 						# sets 'value at eax' register to decimal value 10 (0xa)
>	set $eip = 0xbffff5e8				# setting 'eip' to point to 0xbffff5e8


----------------------------------------------------------------------------------------------------------------


SGDE - 7 (CONVENIENCE VARIABLES AND CALLING ROUTINES)


##	CONVENIENCE Variables
=>	GDB offers a convenience variables to store some data which may be used very often by a 
	reverse engineer. We can create convenience variables to hold data. 
	'set' command is used to create convenient variables.


##	GDB COMMANDS

>	set $var = 10					# creates a convenience variable storing 10
>	set argv[1] = "AAA"				# manipulating argv[1]
> 	set $dyn = (char *)malloc(10)	# dynamically allocates memory to var 'dyn'
> 	call strcpy($dyn, $argv[1])		# calling library function on convenience variables.
									# we can call functions in binary and those linked with
									# it.			
> 	call Addnumbers($var, 20)		# we can also call any function in scope
									# and use convenience variables in it.



---------------------------------------------------------------------------------------------------------------


SDGE - 8 (CRACKING A BINARY AND REVERSE ENGINEERING STUFF)


##	STRINGS
=>	Simple tool to analyse strings in binary. The passwords in the binary will very well be hidden
	by using forms of encryption/encoding.


##	RUNTIME ANALYSIS
=>	Follow some beginers steps
		- setting breakpoints on functions and see what parameters it takes. 
		- analyse behaviour of functions by calling it in gdb 
		- try giving malacious inputs.


---------------------------------------------------------------------------------------------------------------


SDGE - 9 (DISASSEMBLING AND CRACKING SIMPLE BINARY FILE)


##	GDB COMMANDS

>	set disassembly-flavour intel 		# sets at&t syntax to intel
> 	disassemble 0x8048000a				# prints disassembly at address 0x8048000a


---------------------------------------------------------------------------------------------------------------


SGDE - 10 (CONDITIONAL BREAKPOINTS USING VARIABLES AND REGISTERS)


##	CONDITIONAL BREAKPOINTS
=>	They are achieved only when a certain condition is met.


##	GDB COMMANDS

>	break main 						# suppose breakpoint number of main is 1, now we want to
									# set conditions to it.
>	condition 1 counter == 5		# We want to apply a condition on breakpoint 1, condition
									# here is that counter var(in source code) should be equal 
									# to 5. 
>	break *0x8048000a 				# suppose breakpoint number assigned is 2
>	condition 2 $eax != 0									


---------------------------------------------------------------------------------------------------------------


SGDE - 11 (INSTALLING DEBIAN ARMEL IN QEMU)


##	Why ARM? 
=>	ARM based CPU types are very popular. Mobile phones such as anroid phones, iphones typically
	have ARM CPU handling them.
	If we have hardware restrictions, we can create an ARM based emulators, QEMU allows us to do
	ARM emulation (which emulates the hardware). Once we have a hardware emulator, now we need a
	software emulator which in this series will be ARMEL.


##	DOWNLOAD AND INSTALL QEMU
=>	
		$ apt-get build-dep qemu
		$ wget http://wiki.qemu.org/download/qemu-1.2.0.tar. bz2
		$ /.configure --target-list=arm-softmmu	
		$ make
		$ make install


##	DOWNLOAD DEBIAN AND ARMEL IMAGES
=>	Can download from debian website or -

		$ http://people.debian.org/~aurel32/qemu/armel/

		$ launchVM.sh
		$ apt-get update; apt-get install ssh , gcc and gdb


---------------------------------------------------------------------------------------------------------------


SGDE - 12 (Cracking a simple program in ARM)


---------------------------------------------------------------------------------------------------------------


SGDE - 13 (iphone application cracking with gdb)


---------------------------------------------------------------------------------------------------------------


SGDE - 14 (GDB ON 64 BIT SYSTEMS)


NOTE: Look at the 'function calling conventions' for x86-64 bit systems on the bellow link
	  "https://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_calling_convention"


##	64 bit assembly 		
=>	Register sets and some language conventions change, cracking the programs is similar.


---------------------------------------------------------------------------------------------------------------


##	AWSOME GDB COMMANDS


>	info proc mappings					# to check the memory layout 

(gdb)	define hook-stop				# all commands defined in hook-stop will 
										# get executed at once
>	info registers
>	x/24xw $esp
> 	x/2i $eip
>	x/xw $ebp+4
>	end 

>	run < /home/input_file.txt 			# This gives the input_file to binary as STDIN


> 	info frame 							# lists usefull info about frame, such as the
										# saved ebp, eip etc..


-->	Use these 2 commands bellow to be close to normal program's memory layout
(gdb) unset environment LINES
(gdb) unset environment COLUMNS  		# You still have to take care of '_' variable 
							

$> gdb vuln_program core 				# To look at the memory core