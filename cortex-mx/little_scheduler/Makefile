CC = arm-none-eabi-gcc
MACHINE_OPTIONS = -mcpu=cortex-m4 -mthumb -mfloat-abi=soft			# use software FPU 
DIALECT = gnu11
CFLAGS = -c -Wall -std=${DIALECT} ${MACHINE_OPTIONS} -O0
LINKER_SCRIPT = ./stm32_ls.ld
SPECS = --specs=nano.specs		# to use newlib-nano (libc_nano.a)
SPECS_SH = --specs=rdimon.specs	# to use 'librdimon_nano.a' which supports semi-hosting via openOCD
LDFLAGS = $(SPECS) $(MACHINE_OPTIONS) -T $(LINKER_SCRIPT) -Wl,-Map=final.map #-nostdlib
LDFLAGS_SH = $(SPECS_SH) $(MACHINE_OPTIONS) -T $(LINKER_SCRIPT) -Wl,-Map=final.map #-nostdlib

all: main.o led.o stm32_startup.o syscalls.o final.elf
semi: main.o led.o stm32_startup.o syscalls.o final_sh.elf

# target: dependency
main.o: main.c
	# recipe
	$(CC) $(CFLAGS) $^ -o $@

led.o: led.c
	$(CC) $(CFLAGS) $^ -o $@
	
stm32_startup.o: stm32_startup.c
	$(CC) $(CFLAGS) $^ -o $@

syscalls.o: syscalls.c
	$(CC) $(CFLAGS) $^ -o $@

final.elf: main.o led.o stm32_startup.o syscalls.o
	$(CC) $(LDFLAGS) $^ -o $@

final_sh.elf: main.o led.o stm32_startup.o	# no syscalls.o as librdimon_nano.a provides all syscalls
	$(CC) $(LDFLAGS_SH) $^ -o $@

clean:
	echo "deleting files generated by preprocessor, assembly code generator, assembler, linker"
	rm -f *.i *.s *.o *.elf

load:
	openocd -f board/stm32f4discovery.cfg
	 #openocd -f ls /usr/share/openocd/scripts/board/stm32f4discovery.cfg
