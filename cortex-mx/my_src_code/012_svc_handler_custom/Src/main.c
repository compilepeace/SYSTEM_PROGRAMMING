/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

void triggerSVCException(void)
{
	__asm volatile ("svc #4");

	// register attribute is a RECOMMENDATION to the compiler to use register R0 for C variable 'exceptionRetValue'
	//register uint32_t exceptionRetValue __asm("r0");

	// print value returned by SVC exception handler (i.e. svc operand)
//	printf ("svc operand was: %d\n", exceptionRetValue);

	uint32_t exceptionRetValue = 0xff;
	__asm volatile ("mov %0, r0": "=r"(exceptionRetValue): : );
	printf ("svc exception returned: 0x%lx\n", exceptionRetValue);
}

void sum(uint32_t a, uint32_t b)
{
	uint32_t result = 0xcafebabe;

	// compute sum via svc interrupt
	__asm volatile (
		"svc #50 \n\t"
		"mov %0, r0\n\t"
			: "=r"(result)::
		);

	/*
	// sompute sum without using svc interrupt
	__asm volatile (
		"add %0, %1, %2"
		: "=r"(result) : "r"(a), "r"(b) :
	);
	*/

	printf ("sum: %d\n", result);
}

void difference(uint32_t a, uint32_t b)
{
	uint32_t result = 0xcafebabe;
	__asm volatile (
		"svc #60\n\t"
		"mov %0, r0\n\t"
		: "=r"(result)::
	);
	printf ("difference: %d\n", result);
}

int main(void)
{
	//triggerSVCException();
	sum(20, 10);
	difference(70, 9);

    /* Loop forever */
	for(;;);
}

// naked attribute ensures that compiler doesn't generate prologue and epilogue for this function
__attribute__((naked)) SVC_Handler (void)
{
	// pass msp register to svc handler (c version of handler)
	// According to procedure call conventions of ARM (AAPCS), first arg to a function
	// goes into R0 register.
	__asm volatile ("mrs r0, msp");
	__asm volatile ("b SVC_Handler_c");
}

uint8_t SVC_Handler_c(uint32_t *pMSP)
{
/*
	printf ("spBase		: 0x%lx\n", pMSP);
	printf ("r0			: 0x%lx\n", pMSP[0]);
	printf ("r1			: 0x%lx\n", pMSP[1]);
	printf ("r2			: 0x%lx\n", pMSP[2]);
	printf ("r3			: 0x%lx\n", pMSP[3]);
	printf ("r12		: 0x%lx\n", pMSP[4]);
	printf ("lr			: 0x%lx\n", pMSP[5]);
	printf ("saved-pc	: 0x%lx\n", pMSP[6]);
*/

	// extract SVC number (i.e. operand for svc instruction) by parsing binary encoding of instruction
	// 1. get to the address of svc instruction
	uint8_t *resultAddr = (uint8_t *)pMSP[6];
	resultAddr -= 2;

	// 2. extract svc operand from instruction
	uint8_t svcNumber = *resultAddr;
	printf ("svc number (for instruction %02x %02x): 0x%02x\n", resultAddr[0], resultAddr[1], svcNumber);

	uint32_t arg0, arg1, arg2, arg3, result = 0xdeadbeef;
	arg0 = pMSP[0];
	arg1 = pMSP[1];
	arg2 = pMSP[2];
	arg3 = pMSP[3];

	switch(svcNumber)
	{
	case 50: /* return sum */
		result = arg0 + arg1;
		break;
	case 60: /* return difference */
		result = arg0 - arg1;
		break;
	}

	// 3. return 'result' to the caller - by placing result on saved context in stack segment (in place of R0)
	pMSP[0] = result;
}
