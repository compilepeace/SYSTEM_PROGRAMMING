/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#define IRQNO_TIMER2	28
#define IRQNO_I2C1		31

uint32_t *pNVIC_IPR_base	= (uint32_t *)0xE000E400;
uint32_t *pNVIC_ISER_base	= (uint32_t *)0xE000E100;
uint32_t *pNVIC_ISPR_base	= (uint32_t *)0XE000E200;		// IPR0 to IPR59 (60 IPRs for 240 interrupts)

/*
 * Interrupt Priority configuration via NVIC peripheral of ARM Cortex-M4 processor
 */

// set priority via by writing into corresponding IPR register (IPR0 - IPR59) in NVIC (PPB region)
void configure_priority_for_irq(uint8_t irqno, uint8_t priority_value)
{
	// 1. select the ISPRx for particular IRQ
	uint8_t iprx = irqno/4;
	uint32_t *piprx = pNVIC_IPR_base + iprx;		// target IRQ is one of the 4 bytes in this IPR register
	uint8_t pos = (irqno % 4) * 8;

	// 2. configure the priority - set the bits at appropriate position based on priority value ISPR register
	*piprx &= ~(0xff << pos);		// clear bit
	*piprx |= (priority_value << pos);
}

int main(void)
{
	// good practice - Priority configuration should always be done before enabling an interrupt !
	// 1. set the priority level (pre-emptive priority) for MCU peripherals (timer & I2C1 peripheral).
	// In STM32f407 MCU, we got 16 priority levels (bit4-bit7 implemented in IPR by the vendor)
	// Interrupt priority value is determined by -
	// checking which bits are implemented in IPR (for interrupt priority values) by the MCU vendor.
	configure_priority_for_irq(IRQNO_TIMER2, 0x80);
	configure_priority_for_irq(IRQNO_I2C1, 0x70);		// change priority value to observe interrupt nesting

	// 2. manually pend the interrupt - i.e. set the interrupt pending bit in NVIC PR (Pending Register)
	// since the pending bit of TIMER2 is set, its interrupt will get generated when enabled via ISER register
	*pNVIC_ISPR_base |= (1 << IRQNO_TIMER2);
	//*pNVIC_ISPR_base |= (1 << IRQNO_I2C1);

	// 3. enable IRQs via NVIC ISER register (Interrupt Set Enable Register)
	// this will cause the interrupts to be generated
	*pNVIC_ISER_base |= (1 << IRQNO_I2C1);
	*pNVIC_ISER_base |= (1 << IRQNO_TIMER2);

    /* Loop forever */
	for(;;);
}


// ISRs (Interrupt Service Routines) aka interrupt handlers aka exception handler routines
// check startup file where reset vector is defined, which is where the interrupt handler
// routines are registered for various peripherals attached to the MCU.
void TIM2_IRQHandler(void)
{
	printf ("Insider ISR: TIMER(TIM2) generated an interrupt\n");
	*pNVIC_ISPR_base |= (1 << IRQNO_I2C1);
	while (1);
}

void I2C1_EV_IRQHandler(void)
{
	printf ("Inside ISR: I2C1 generated an interrupt\n");
}
