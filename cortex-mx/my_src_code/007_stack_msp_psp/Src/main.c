/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

/*
	0x2000_0000	|-----------| <-- SRAM_START
				|			|
				|			|
				|			|
				|			|
	0x2001_fe00	|-----------| <-- STACK_MSP_END = STACK_PSP_START (STACK_MSP_START - 512)
				|			|
	Ox2002_0000	|			| <-- SRAM_END = STACK_START = STACK_MSP_START
				-------------
*/

#define SRAM_START 0x20000000U
#define SRAM_SIZE ( 128 * 1024 )				// 128K SRAM size
#define SRAM_END  ((SRAM_START) + (SRAM_SIZE))
#define STACK_START SRAM_END

#define STACK_MSP_START STACK_START
#define STACK_MSP_END (STACK_MSP_START - 512)
#define STACK_PSP_START STACK_MSP_END


// This function switches our current process stack over to PSP, i.e. achieving SP = PSP.
// We have to write naked function as a regular function has prologue and epilogue
// which will use stack pointer while entering and exiting this function routine.
// and since we are setting up SP to PSP, a regular function call's prologue will
// push/save LR, FP on original SP while epilogue will pop values from PSP stack segment,
// this will lead to inconsistent values and possibly segmentation fault. Therefore,
// we use naked function.
__attribute__((naked)) void change_sp_to_psp()
{
	__asm volatile (".equ SRAM_END, (0x20000000 + (128*1024))");
	__asm volatile (".equ PSP_START, (SRAM_END - 512)");
	__asm volatile ("ldr r1, =PSP_START");	// use PC-relative addressing to load an immediate value into r1
	__asm volatile ("MSR PSP, r1");			// initialize PSP with a start address
	__asm volatile ("mov r1, 0x2");			// 0x2 = b'0000_0010'
	__asm volatile ("MSR CONTROL, r1");		// set SPSEL bit (@ index 1) indicating a copy from PSP to SP
	__asm volatile ("bx lr");				// jump back to LR
}

void generateException()
{
	__asm volatile ("svc #7");		// generate svc exception
}

int main(void)
{
	// while executing main(), the processor is running in thread-mode.
	// Therefore, it should be using value in PSP as Stack pointer (R13).
	change_sp_to_psp();				// LR will store the address of next instruction
	generateException();

    /* Loop forever */
	for(;;);
}

/*
 * This is SVC exception handler. name identifier taken from startup script (startup_stm32f407vgtx.s)
 */
void SVC_Handler (void)
{
	printf ("In SVC exception handler");
}
