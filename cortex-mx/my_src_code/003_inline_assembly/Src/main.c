/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

/*

Challenge 1 – read a special register (CONTROL) into a variable.
uint32_t control_reg;
__asm volatile (“mrs %0, CONTROL” : “=r”(control_reg) : : );


Challenge 2 – copy the content of C variable (var1) into var2.
int var1=10, var2;
__asm (“mov %0, %1”: “=r”(var2) : “r”(var1) : );		// var2 = var1


Challenge 3 – copy the content of a pointer into a variable.
int var, *p;
p = (int *) 0x20000008;
__asm volatile (“ldr %0, [%1]”: “=r”(var) : “r”(p) : );	// var = *p

*/

void addition()
{
	//__asm volatile ("mov r1, #0x20001000");
	//__asm volatile ("mov r2, #0x20001004");
	__asm volatile ("ldr r1, =#0x20001000");	// one way to load immediate values can be loaded into registers.
	__asm volatile ("ldr r2, =#0x20001004");	// ldr r2, [pc, #20]   ; (0x8000204 located after disassembly of addition())
	__asm volatile ("ldr r0, [r1]");
	__asm volatile ("ldr r1, [r2]");
	__asm volatile ("add r0, r0, r1");
	__asm volatile ("str r0, [r2]");
}

/*
each input/output operands in an inline-assembly statement
are described by a "constraint string" followed by C expression

syntax = "<constraint_string>"(<C_expression>)
where, constraint_string = constraint character + constraint modifier
*/
int addTwoNumbers (int a, int b)
{
	int result = 0;
	/*
	 * constraint specifiers
	 * r = forces the compiler to use a GPR (general purpose registers) in place of %0 (or %1, %2 etc. placeholders)
	 * i = indicates use of immediate value instead of variable
	 */
	__asm volatile (
			"mov r1, %1\n\t"					// r1 = a
			"mov r2, %2\n\t"					// r2 = b
			"add r3, r1, r2\n\t"				// r3 = r1 + r2
			"add %0, r3, %3\n\t"				// result = r3 + 0x7 (immediate value)
			: "=r"(result): "r"(a), "r"(b), "i"(0x7)
	);
	/*
The above inline assembly code gets assembled into following instructions,
have a close look on how placeholders (%0, %1, %2, %3) have been replaced by
registers and immediate values by the compiler. Yeahhh !
 67        	__asm volatile (
0800021a:   ldr     r3, [r7, #4]
0800021c:   ldr     r2, [r7, #0]
0800021e:   mov     r1, r3
08000220:   mov     r2, r2
08000222:   add.w   r3, r1, r2
08000226:   add.w   r3, r3, #7
0800022a:   str     r3, [r7, #12]
	 */
	return result;
}

/*
 * check misclaneous instructions (ISA section) in Generic User guide for ARM Cortex processors
 * Since Control Registers are special purpose registers, a simple mov instruction won't work here.
 * We must use - MRS (read) and MSR (write) to access special purpose registers.
 */
int readControlRegister()
{
	int control_reg;
	__asm volatile ("MRS %0, CONTROL" : "=r"(control_reg) : : );
/*
 97       	__asm volatile ("MRS %0, CONTROL" : "=r"(control_reg) : : );
08000240:   mrs     r3, CONTROL
08000244:   str     r3, [r7, #4]
 */

	return control_reg;
}


int main(void)
{
	addition();
	addTwoNumbers(10, 20);
	readControlRegister();
    /* Loop forever */
	for(;;);
}
