/*
	This code is taken from "Hacking: The Art of Exploitation" by Jon Erickson.
	Few modifications are done to make this code suitable for teaching modern
	binary exploitation on both 32 and 64 bit architectures.

	NOTE to Jon Erickson
	Can't thank you enough for writing this amazing book and sharing your
	perspective in the field of binary exploitation. I'm quite sure the world
	continues to learn from your experience !

GCC version - gcc (Debian 12.2.0-14) 12.2.0
❯ uname -a
Linux kali 6.1.0-kali5-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.12-1kali2 (2023-02-23) x86_64 GNU/Linux

# Trigger exploitation                                    
❯ ./001_overflow_example.elf $(python2 -c 'print("A"*16 + "\xbe\xba\xfe\xca")') 
*/ 


#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]) {
	int value = 5;
	char buffer_one[8], buffer_two[8];

	if (argc < 2){
		fprintf (stderr, "Usage: %s <string>\n", argv[0]);
		return 1;
	}

	strcpy(buffer_one, "one"); /* Put "one" into buffer_one. */
	strcpy(buffer_two, "two"); /* Put "two" into buffer_two. */
	
	printf("[BEFORE] buffer_two is at %p and contains \'%s\'\n", buffer_two, buffer_two);
	printf("[BEFORE] buffer_one is at %p and contains \'%s\'\n", buffer_one, buffer_one);
	printf("[BEFORE] value is at %p and is %d (0x%08x)\n", &value, value, value);

	printf("\n[STRCPY] copying %d bytes into buffer_two\n\n", strlen(argv[1]));
	strcpy(buffer_two, argv[1]); /* Copy first argument into buffer_two. */

	printf("[AFTER] buffer_two is at %p and contains \'%s\'\n", buffer_two, buffer_two);
	printf("[AFTER] buffer_one is at %p and contains \'%s\'\n", buffer_one, buffer_one);
	printf("[AFTER] value is at %p and is %d (0x%08x)\n", &value, value, value);

	return 0;
}
