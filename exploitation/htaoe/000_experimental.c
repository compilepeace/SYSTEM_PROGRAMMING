/*

Author - Abhinav Thakur
Email  - thakurxabhi@gmail.com

Description: This is an experimental program to exploit stack buffer overflow using various ways -

Possible ways of achieving Shellcode INJECTION - 
> INSIDE buffer (on vulnerable stack frame)
> AFTER buffer & saved return pointer (on vulnerable stack frame)
> via environment variables (IPC: passed by exploit to target program)

Possible ways of achieving Shellcode EXECUTION -
> overwriting critical local variables (bypasses canary checks by default)
> overwriting saved return pointer (generic to every program)

*/

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ENV_VAR "SHELLCODE"

void spawn_shell()
{
	printf ("spawning shell now...\n");
	execl("/bin/sh", "sh", (char *)NULL);
}

int main (int argc, char *argv[])
{
	char buffer[1000];

	printf ("[+] pid: %d\n", getpid());

	// strcpy
	if (argc > 1){
		printf ("[+] copying magic-string provided via cmdline\n");
		printf ("[+] strcpy(buffer, %s)\n", argv[0]);
		strcpy (buffer, argv[1]); 
		printf ("[+] copied!\n");
	}

	else{
		printf ("[+] Taking input via stdin\n");
		printf ("[+] gets(buffer): Please input a magic-string: ");
		gets(buffer);
		if (strlen(buffer) < 1000)
			printf ("[-] I wish you had a longer input\n");
		else
			printf ("[+] Now, we're looking at something interesting\n");
	}
	
	printf ("\n[+] Your input is now stored inside buffer: %s\n", buffer);

	char *envAddr = getenv(ENV_VAR);
	if (envAddr == NULL){
		perror ("getenv");
		return 1;
	}

	printf ("[+] %s env-var is @: %p (dumping it on stderr)\n", ENV_VAR, envAddr);
	fprintf (stderr, "%s", envAddr);
	printf ("\n[*] returning now\n");
	//sleep(10);			// uncomment it to attach gdb to it (gdb -p <PID>)
	return 0;
}
