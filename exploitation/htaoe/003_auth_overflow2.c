/*
        This code is taken from "Hacking: The Art of Exploitation" by Jon Erickson.
        Few modifications are done to make this code suitable for teaching modern
        binary exploitation on both 32 and 64 bit architectures.

        NOTE to Jon Erickson
        Can't thank you enough for writing this amazing book and sharing your
        perspective in the field of binary exploitation. I'm quite sure the world
        continues to learn from your experience !

TEACHING
Hijacking execution flow by writing to a control point - OVERWRITING saved return address (on stack frame)

GCC version - gcc (Debian 12.2.0-14) 12.2.0
❯ uname -a
Linux kali 6.1.0-kali5-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.12-1kali2 (2023-02-23) x86_64 GNU/Linux

# Trigger exploitation
> 
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void spawn_shell()
{
	printf ("spawning shell now...\n");
	execl("/bin/sh", "sh", (char *)NULL);
}

int check_authentication(char *password) {
	/* CONTROL POINT : reversing the order of declaration should now allocate auth_flag variable above 
						the password_buffer but the auth_flag variable is still allocated below password_buffer,
						hence overflow into this variable is still possible :)
		(gdb) x/s password_buffer
		0x7fffffffdcf0: ""
		(gdb) x/xw &auth_flag                                       
		0x7fffffffdd0c: 0x00000000
	*/
	char password_buffer[16];
	int auth_flag = 0;

	strcpy(password_buffer, password);
	if(strcmp(password_buffer, "brillig") == 0)
		auth_flag = 1;
	if(strcmp(password_buffer, "outgrabe") == 0)
		auth_flag = 1;

	return auth_flag;
}

int main(int argc, char *argv[]) {
	if(argc < 2) {
		printf("Usage: %s <password>\n", argv[0]);
		exit(0);
	}
	if(check_authentication(argv[1])) {
		printf("\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
		printf("Access Granted.\n");
		printf("-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
	} else {
		printf("\nAccess Denied.\n");
	}
}
